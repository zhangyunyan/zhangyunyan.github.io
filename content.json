[{"title":"ES6新特性","date":"2017-03-28T08:38:29.235Z","path":"2017/03/28/ES6新特性/","text":"一、作用域 块级作用域 块级变量let 块级常量 const 二、箭头函数 sum = (a,b)=&gt; a + b nums.forEach(v=&gt; {console.log(v)}) 词法 this 三、参数处理 默认参数值 剩余参数 展开运算符 四、模板字面量 多行字符串 字符串插值 带标签的模板字面量 原始字符串 五、原有字面量加强 更安全的二进制字面量(0b1111101) 更安全的八进制字面量(0o767) 字符串支持Unicode String.fromCodePoint String.prototype.codePointAt 正则表达式字面量添加 Unicode 正则表达式添加y标记，支持粘滞匹配 对象属性加强 属性定义支持短语法obj = {x,y} 属性名支持表达式 obj = {[“baz”+quux()]:42} 添加proto属性，但不建议使用 六、解构赋值 匹配 [b,a] = [a,b] 对象匹配 let {a,b,c} = objABC 参数匹配 function g({name:n,val:v}){} 七、模块 导入(import) 导出(export) 默认导出(export default) 八、类 使用extends继承 重写构造器 super关键字 九、迭代 迭代器 for of 十、生成器 十一、promise. 十二、元编程 代理(proxy) 反射(Reflex) 十三、新增数据类型 Symbol类型 Set类型 Map类型 WeakSet类型 WeakMap类型 TypedArray类型 十四、原有内置对象API增强 Object.assign Array.from Array.of Array.prototype.fill Array.prototype.find Array.prototype.findIndex Array.prototype.copyWithin Array.prototype.entries Array.prototype.keys Array.prototype.values String.prototype.includes String.prototype.repeat String.prototype.startsWidth String.prototype.endsWidth() Number.EPSILON Number.isInteger Number.isSafeInteger Number.isFinite Number.isNaN(“NaN”) Math.acosh Math.hypot Math.imul Math.sign Math.trunc","tags":[]},{"title":"ES6的promise","date":"2017-03-28T08:38:09.980Z","path":"2017/03/28/ES6中promise/","text":"什么是PromisePromise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ES6中的Promise先在控制台打印出Promise看看，console.dir(Promise);显示如下; 由上图可知，Promise是一个函数，自己身上有all、race、reject、resolve等方法，原型上有then、catch等方法 ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected 创造了一个Promise实例： 123456789101112var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); var num = Math.random(); if(num&gt;=0.5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字小于0.5&apos;); &#125; &#125;, 2000);&#125;); 上面的代码中，设置了一个2s后执行的定时器。 2s以后输出“执行完成”，然后生成一个随机数，如果数字大于等于0.5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为“失败”的原因。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“已解决”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“拒绝”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise示例123456789101112function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&apos;Could not load image at &apos; + url)); &#125;; image.src = url; &#125;);&#125; 使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。 1234567891011121314151617181920212223242526function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 2000); &#125;); return p;&#125;getNumber().then( function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); &#125;, function(reason, data)&#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： resolved 1（数字随机，只是个举例） 或者是 rejected 数字太小了（ Promise.prototype.then()then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 从表面上看，Promise只是简化了层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。 12345678910111213141516171819202122232425262728293031323334353637383940function runAsync1()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成1&apos;); resolve(&apos;数据1&apos;); &#125;, 2000); &#125;);&#125;function runAsync2()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成2&apos;); resolve(&apos;数据2&apos;); &#125;, 2000); &#125;);&#125;function runAsync3()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成3&apos;); resolve(&apos;数据3&apos;); &#125;, 2000); &#125;);&#125;//调用runAsync1().then(function(data)&#123; console.log(data); return runAsync2(); //return的是一个promise对象&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); 1234567代码执行的结果执行完成1数据1执行完成2数据2执行完成3数据3 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 12345new Promise(function(resolve, reject) &#123; throw new Error(&apos;test&apos;);&#125;).catch(function(error) &#123; console.log(error); &#125;); 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。需要注意的是，catch方法返回的还是一个 Promise对象，因此后面还可以接着调用then方法。 123456789101112131415var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log(&apos;oh no&apos;, error);&#125;).then(function() &#123; console.log(&apos;carry on&apos;);&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 下面是一个例子，其中 runAsync1、 runAsync1 和runAsync3上面的例子中已有定义 Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 上述结果为: 1234执行完成1执行完成2执行完成3[&quot;数据1&quot;,&quot; 数据2&quot;,&quot;数据3&quot;] 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 all方法的效果实际上是「谁跑的慢，以谁为准执行回调」(以执行最慢的那个为准的话这个时候所有的数据都可以获取到的，以数组的形式展现)，那么相对的就有另一个方法race「谁跑的快，以谁为准执行回调」。 我们把上面runAsync1的延时改为1秒来看一下： 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 1234执行完成1数据1执行完成2执行完成3 在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： 12345678910111213141516171819202122232425262728//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = &apos;xxxxxx&apos;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。","tags":[]},{"title":"markdown使用","date":"2017-03-28T07:29:02.205Z","path":"2017/03/28/markdown使用/","text":"插入图片 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 Markdown 语法:123456789101112131415A First Level Header====================A Second Level Header---------------------Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.The quick brown fox jumped over the lazydog&apos;s back.### Header 3&gt; This is a blockquote.&gt;&gt; This is the second paragraph in the blockquote.&gt;&gt; ## This is an H2 in a blockquote 输出 HTML 为：12345678910111213&lt;h1&gt;A First Level Header&lt;/h1&gt;&lt;h2&gt;A Second Level Header&lt;/h2&gt;&lt;p&gt;Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.&lt;/p&gt;&lt;p&gt;The quick brown fox jumped over the lazydog&apos;s back.&lt;/p&gt;&lt;h3&gt;Header 3&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;This is a blockquote.&lt;/p&gt;&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;&lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法:1234Some of these words *are emphasized*.Some of these words _are emphasized also_.Use two asterisks for **strong emphasis**.Or, if you prefer, __use two underscores instead__. 输出 HTML 为:1234&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：123* Candy.* Gum.* Booze. 加号：123+ Candy.+ Gum.+ Booze. 和减号123- Candy.- Gum.- Booze. 都会输出 HTML 为：12345&lt;ul&gt;&lt;li&gt;Candy.&lt;/li&gt;&lt;li&gt;Gum.&lt;/li&gt;&lt;li&gt;Booze.&lt;/li&gt;&lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记：1231. Red2. Green3. Blue 输出 HTML 为：12345&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。123* A list item.With multiple paragraphs.* Another item in the list. 输出 HTML 为：12345&lt;ul&gt;&lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt;&lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接：1This is an [example link](http://example.com/). 输出 HTML 为：12&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性：1This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为：12&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：12345I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为：1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot;title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot;title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：123I start my morning with a cup of coffee and[The New York Times][NY Times].[ny times]: http://www.nytimes.com/ 输出 HTML 为：12&lt;p&gt;I start my morning with a cup of coffee and&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）：1![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式：12![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为：1&lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：123I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `&amp;mdash;`instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为：12345&lt;p&gt;I strongly recommend against using any&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;&lt;p&gt;I wish SmartyPants used named entities like&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encodedentites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法:12If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes: For example. 输出 HTML 为：123456&lt;p&gt;If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/code&gt;&lt;/pre&gt; 1转载：http://www.appinn.com/markdown/","tags":[]},{"title":"MVC、MVP、MVVM之间的关系","date":"2017-03-28T07:26:09.493Z","path":"2017/03/28/MVC和MVP及MVVM之间的关系/","text":"一、MVC什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 二、MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 三、MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然","tags":[]},{"title":"css实现九宫格（兼容问题）","date":"2017-03-28T07:26:09.422Z","path":"2017/03/28/九宫格/","text":"前段时间，我的 leader Henry在群里面分享了一道一淘的面试题。 题目非常的有趣，忙完前阵的工作之后突然记起，也尝试做了一下。 129个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 做成九宫格大家都会，但题目的陷阱就在hover上。鼠标hover到格子4，格子5时，其实他们“共用”了一条边。由于是纯css实现的，我们不可能说用js去动态改变dom，因此怎样实现“公用边”就成为了难点。 尝试的过程： 我的第一个想法，用“叠加”的方式实现“公用边”； 后来的想法，用table的border-collapse实现“公用边”； 在table想法的基础上改进； 一种更简便的做法，不需要border，见九宫格(二)我的第一个想法先做做看，尝试永远是第一步。我将9个div都设置了5px的border，排成了九宫格，添加了hover，这时候初始的效果是：这样其实格子之间的距离是两倍border（10px）。需要再将中间的一竖（2，5，8）设置margin-left:-5px;margin-right:-5px;,再将中间的一横（3，4，5）设置margin-top:-5px;margin-bottom:-5px;，这样等于是强制把格子间的距离“拉”到5px。到这一步，简单的九宫格是完成了，但hover之后会发现，格子的边会被挡住（格子5的下边和右边分别被格子8和格子6挡住）。因为这里“公用边”的思路准确来说是“重合边”，是用负值的margin强制定位的。而我的解决方式是hover时添加z-index:999，让hover到的格子在最上层显示而不会被挡住。同时，不要忘记在9个div的css里面添加一句让z-index生效的position: relative;，具体原因看这里。代码君：1.html：1234567891011&lt;div id=&quot;test0&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;lr_indent tb_indent&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 2.css:1234567891011121314151617181920212223242526272829#test0&#123; margin: 30px; width: 200px; height: 200px;&#125;#test0 div&#123; width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative;&#125;#test0 .lr_indent&#123; margin-left: -5px; margin-right: -5px;&#125;#test0 .tb_indent&#123; margin-top: -5px; margin-bottom: -5px;&#125;#test0 div:hover&#123; border: 5px solid #f00; z-index: 999; background: #eee;/*必须加这一句，在IE6，7有bug*/&#125; 思考：这样的方式好吗？不够好。这才是9宫格，如果是16，25，…，81个格子，设置margin缩进的人力代价是很高的。兼容性，在IE6，7下，负值margin在hover时候有bug。 后来的想法经过第一次尝试，我得到一个经验：要用一种通用的方法去解决“公用边”，而不是分别设置.lr_indent和.tb_indent。随即我想到了表格。作为table，它有个很突出的属性，就是合并border，css里面的设置为border-collapse:collapse;。ok，这就是key point。 按照这个思路，我简单的编写了代码，一开始我把hover定位到td上面去，发现hover时也会出现第一个想法中“挡住”的情况。而且，去将td的position改变，再添加z-index的方法是不可能有用的(z-index不会起效)。 我的方法是在td中包含一个span，把hover定位到span中去，td设置为position:relative;，span设置为position:absolute;，这时候的hover就可以设置让span的border不被挡住展示了。代码君又来了：html：12345678910111213141516171819&lt;div id=&quot;test1&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;9&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css：123456789101112131415161718192021222324252627282930*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test1 td&#123; width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center;&#125;#test1 td span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test1 td span:hover&#123; border: 5px solid #f00; margin-top:-5px; margin-left: -5px;&#125; 别忘了span在hover时，必须设置一个负的margein-top和margein-left，以保证红色边框恰好定位在格子四周。见css君最后的片段。假如不设置，你看到的将是这样：本以为已经大功告成了，在IE中测试却让我傻了眼：（ps：作为前端一枚，我已经做好了妥妥的心理准备，但此情此景还是让人喷出一口老血……） 改进，改进说实话，table和div之争这么多年，大家都在页面中用越来越多的div，而越发的鄙视table，反而对table的熟悉程度反应了前端们的基础是否扎实。吃一堑长一智，这句话特别适用于在table中翻江倒海的亲们。 改进！ 首先这个bug（也无所谓是不是bug，算是浏览器的差异性吧）我知道，在table的td里面设置了position:relative;就会在IE中出现这样的情况。注意是所有的IE哦，包括IE10。而根据第二个思路，最后的hover定位的元素为span，它本身设定为position:absolute;它的父级元素必须得设置position:relative;才能完成题目功能，这是毋庸置疑的。 既然现在span的父级td不能设置position:relative;，我就在它们之间添加一个div，用来做span的容器。 代码君再一次来了：html:12345678910111213141516171819&lt;div id=&quot;test2&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;4&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;6&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;7&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;8&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;9&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css:1234567891011121314151617181920212223242526272829303132333435*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test2 td&#123; width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top;&#125;#test2 td div&#123; position:relative; width: 50px; height: 50px;&#125;#test2 td div span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test2 td div span:hover&#123; border: 5px solid #f00; margin-left: -5px; margin-top: -5px;&#125; OK，效果达成！最终完成的效果 最后吐槽，不对，总结一下下：先到IE上去测，再转到其它浏览器，以少走弯路，这叫擒贼先擒王-_-!；win8的metro布局最近挺流行的，有时候table比div好用；IE君，你真是……此处省略1024个字","tags":[]},{"title":"路由","date":"2017-03-21T04:54:58.000Z","path":"2017/03/21/路由/","text":"为什么路由的路径后面加上 “#!/” #是哈希值，默认是不会被浏览器搜索到的，加上！号就可以被搜索到了","tags":[]},{"title":"less","date":"2017-03-19T12:56:52.445Z","path":"2017/03/19/less/","text":"Less 是一门一种动态样式 语言，它扩充了CSS语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。 客户端使用外联样式 引入你的 .less 样式文件的时候要设置 rel 属性值为 “stylesheet/less”: 12345&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot;&gt;内联样式如下：&lt;style type=&quot;text/less&quot;&gt; // less 代码&lt;/style&gt; 接下来 下载 less.js 并通过 标签将其引入，放置于页面的 元素内： 1&lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;","tags":[]},{"title":"ES6","date":"2017-03-19T12:55:15.852Z","path":"2017/03/19/ES6/","text":"环境搭建 创建.gitignore 和 readme.md文件：touch .gitignore README.md 初始化package.json文件 npm install babel-cli babel-preset-es2015 –save-dev 在package.json的scripts中配置：”dev”:”babel src -d dist -w” 创建.babelrc文件：touch .babelrc; 在里面配置：123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; 基本项目目录结构的说明1234src es6源代码dist es6-&gt;es5可运行代码index.html 加载dist目录下的代码，测试package.json 如何开发1npm run dev 箭头函数 箭头函数 使用=&gt;对函数定义的简写。支持两种写法：表达式和函数体 表达式 1234let fn3=p=&gt;p中间的p代表参数，箭头后面的p，代表返回值；let fn3=()=&gt;&apos;无参数输入的箭头函数&apos;let fn3=(a,b)=&gt;a+b; 同上; 函数体(显式写法) 1234let fn3=(a,b)=&gt;&#123; var m=a+b; return m;&#125; 注意：箭头函数体中this : 共用父级作用域的关键字this； 定义一个类及类的继承 创建类，添加公有方法和静态方法； 123456789101112class Father&#123; //用class创建一个类 construcotr(name,age)&#123;//用constructor创建构造函数 this.name=name; this.age=age; &#125; getMessage()&#123;//添加公有方法 console.log(this.name+&apos;的年龄是&apos;+this.age+&apos;岁了&apos;) &#125; static like()&#123; //静态方法 console.log(&apos;我是静态方法&apos;) &#125;&#125; 构造函数的继承 123456789class Sun extends Father&#123;//子类继承父类 constructor(name,age,color)&#123; super(name,age);//必须写； this.color=color; &#125; getColor()&#123; console.log(this.name+&apos;喜欢的颜色是：&apos;+this.color); &#125;&#125; 增强的对象字面量优点：1）写法简化 2）原型继承–类似于“类”；12345var obj=&#123;data:123&#125;;var a=1;var b=&apos;2&apos;;var fn=(n,m)=&gt;console.log(n+m);var objOther=&#123;__proto__:obj,a,b,fn&#125; 模板字符串123var name=&apos;tangtang&apos;;var age=2;var str=`$&#123;name&#125;已经$&#123;age&#125;岁了`； 注意：用的是``(键盘左上角1旁边的)而不是普通的单引号‘’; 解构赋值123var obj=&#123;a:1,b:&apos;2&apos;,fn()&#123;console.log(&apos;我是函数&apos;)&#125;&#125;;var &#123;a,b,fn&#125;=obj;//这样就能拿到a,b,fn任何一个属性的值；var &#123;Alert,ListView,Text&#125;=reuqire(&apos;reactNative&apos;);//同上； 默认参数，任意参数，扩展运算符 默认参数-减少代码逻辑：function(a=’tangtang’,b=123){} 任意参数-不依赖arguments解决常见问：function(a,…keys) 扩展运算符:123var ary=[1,23,21];var newAry=[...ary,1000,10000];Math.max(...ary); let和const 新增块级作用域，用let； const是常量，不能重复赋值； 都没有预解释；","tags":[]},{"title":"html包含另外html页面的方法","date":"2017-03-19T04:06:36.785Z","path":"2017/03/19/html包含另外html页面的方法/","text":"一、用object对象1&lt;object style=&quot;border:0px&quot; type=&quot;text/x-scriptlet&quot; data=&quot;111.html&quot; width=100% height=500&gt;&lt;/object&gt;（这个在ie下面不正常） 二、用iframe1&lt;iframe src=&quot;111.html&quot; style=&quot;width:680px; height:auto;&quot;&gt;","tags":[]},{"title":"MongoDB","date":"2017-02-17T11:08:58.000Z","path":"2017/02/17/mongoDB/","text":"安装MongoDB安装1264mongod --dbpath=./data 1232位mongod --dbpath=./data --storageEngine=mmapv1(搜索引擎) mongoose导入mongoose模块1var mongoose = require(&apos;mongoose&apos;); 服务器的实例和服务器分别是谁？？？？连接数据库connect，201613node为数据库名1mongoose.connect(&apos;mongodb://localhost/201613node&apos;); 集合的骨架模型:规定了集合中文档的字段名和字段的类型123456var PersonSchema = new mongoose.Schema(&#123; name:String, //人的姓名 age:Number, //人的年龄 home:String&#125;);//此骨架模型指定存的时候只能是name和age不能是别的，而且类型也是指定的类型 外键1234567 * 节省空间 第一定义多次使用 * 方便修改 一次修改多处修改&#123; cardid:417, //主键 name:&apos;杨过&apos;， cardfk:418 //外键&#125; 根据schema定义操作数据库的对象模型(集合名称=模型名-&gt;转小写-&gt;转复数)Person-&gt;person-&gt;people1var Person = mongoose.model(&apos;Person&apos;,PersonSchema); Person.create创建文档并插入数据库123Person.create(&#123;id:5,name:&apos;zfpx5&apos;,age:50,home:&quot;北京&quot;&#125;,function(err,result)&#123; console.log(err);&#125;); 121.如果传入的类型多于schema的定义，那么多余的字段会忽略掉2.如果传入的值和schema规定的类型不匹配，那么mongoose会尝试进行数据类型转换，如果转换成功，则成功保存，如果转换失败，则保存失败 Person.find查询：返回永远是数组格式，没有东西返回则也返回个空数组，12345* 参数1 是查询的条件，当第一个参数为&#123;&#125;，表示查询所有* 参数2 规定想要查询出来的字段的名称* &#123;age:1&#125; 表示只查询这些字段，其它字段均忽略掉不返回* &#123;age:0&#125; 表示只排除掉这些字段，其它字段均返回* 参数3 回调函数 1234Person.find(&#123;&#125;,&#123;age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;); Person.update跟新默认是更新一条123456789Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function(err,result)&#123; console.log(result); &#125;);Person.update(&#123;age:&#123;$lt:50&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function (err, result) &#123; console.log(result);&#125;);Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function (err, result) &#123; console.log(result);&#125;); 1234&#123; ok: 1, nModified: 1, n: 1 &#125;&#123; ok: 1, nModified: 0, n: 1 &#125;&#123; ok: 1, nModified: 1, n: 2 &#125;ok=1:是成功了;nModified:修改的条数;n:匹配到的条数 1234561 参数是更新的条件,更新的范围 * $in 表示在一个数组范围内 &#123;age:&#123;$in:[50,100]&#125;&#125; * $gt 大于 $gte大于等于 $lt小于 $lte 小于等于2 参数是更新后的值对象3 更新选项 &#123;multi:true&#125;默认是更新一条，加上他为更新所有******************4 回调函数(错误对象,更新结果) Person.remove删除的时候默认会删除掉全部匹配的数据,更新默认是更新一条1234Person.remove(&#123;name:&apos;zfpx2&apos;&#125;,function(err,result)&#123; console.log(err); console.log(result.result);&#125;) 根据ID查询文档1234Person.findById(&quot;58b101946d87bf0d34abaa7a&quot;,function(err,doc)&#123; console.log(err); console.log(doc);&#125;); Person.findOne查询,最多找一条记录,如果匹配一条满足条件的则停止继续查找123Person.findOne(&#123;&#125;,function(err,docs)&#123; console.log(docs); &#125;); mongoose.Promise=Promise;如果不加的话会有警示，mongoose.Promise为被废弃的，需要改为Promise**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//导入mongoose模块var mongoose = require(&apos;mongoose&apos;);//连接数据库mongoose.connect(&apos;mongodb://localhost/201613node&apos;);/** * 集合的骨架模型 * 规定了集合中文档的字段名和字段的类型 */var PersonSchema = new mongoose.Schema(&#123; name:String, //人的姓名 age:Number, //人的年龄 home:String&#125;);//根据schema定义操作数据库的对象模型//集合名称=模型名-&gt;转小写-&gt;转复数// Person-&gt;person-&gt;peoplevar Person = mongoose.model(&apos;Person&apos;,PersonSchema);/** * 如果传入的类型多于schema的定义，那么多余的字段会忽略掉 * 如果传入的值和schema规定的类型不匹配，那么mongoose会尝试进行数据类型转换，如果转换成功，则成功保存，如果转换失败，则保存失败 *//*Person.create(&#123;id:5,name:&apos;zfpx5&apos;,age:50,home:&quot;北京&quot;&#125;,function(err,result)&#123; console.log(err);&#125;);*//** * 查询 * 1参数是查询的条件 * 2参数 规定查询出来的字段的名称 * :1 表示只查询这些字段，其它字段均忽略掉不返回 * :0 表示只排除掉这些字段，其它字段均返回 *///BadValue Projection// cannot have a mix of inclusion and exclusion.// 除了男生都站起来 只让女生站起来/*Person.find(&#123;&#125;,&#123;age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;);*/// &#123; ok: 1, nModified: 1, n: 1 &#125;// &#123; ok: 1, nModified: 0, n: 1 &#125;//&#123; ok: 1, nModified: 1, n: 2 &#125;// ok=1 是成功了 nModified 修改的条数 n是查找匹配到的条数/** * 1 参数是更新的条件 更新的范围 * 2 参数是更新后的值对象 * 3 更新选项 &#123;multi:true&#125;什么意思？ * 4 回调函数，错误对象 更新结果 * $in 表示在一个数组范围内 * $gt 大于 $gte大于等于 $lt小于 $lte 小于等于 */// Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function(err,result)&#123;// console.log(result);// &#125;);//删除的时候默认会删除掉全部匹配的数据/*Person.remove(&#123;name:&apos;zfpx2&apos;&#125;,function(err,result)&#123; console.log(err); console.log(result.result);&#125;)*///根据ID查询文档Person.findById(&quot;58b101946d87bf0d34abaa7a&quot;,function(err,doc)&#123; console.log(err); console.log(doc);&#125;);//查询找最多一条记录 如果匹配一条满足条件的则停止继续查找Person.findOne(&#123;&#125;,function(err,docs)&#123; console.log(docs);&#125;); .skip()跳过指定的条数.limit()限定返回的条数.sort({age:1}) 排序，按哪个字段排序，正序1还是倒序-1.exec(function(err,docs){}) 执行1当skip sort limit的时候并没有真正执行查询,当调用exec的时候才真正执行查询 123456789101112131415161718192021222324252627282930313233343536var mongoose = require(&apos;mongoose&apos;);mongoose.Promise = Promise;//连接数据库mongoose.connect(&apos;mongodb://localhost/blog&apos;);//定义schemavar UserSchema = new mongoose.Schema(&#123; name:String, age:Number&#125;);//定义Modelvar User = mongoose.model(&apos;User&apos;,UserSchema);var users = [];for(var i=0;i&lt;10;i++)&#123; users.push(&#123;name:&apos;zfpx&apos;+(i+1),age:i+1&#125;);&#125;/*User.create(users,function(err,docs)&#123; console.log(docs);&#125;);*//** * 分页查询 * pageNum 查询第几页 * pageSize 查询每页的条数 */var pageNum = 1;//查询第几页var pageSize = 10;//查询每页的条数// 跳过(忽略掉)前6条, 取3条User.find(&#123;&#125;) //当skip sort limit的时候并没有真正执行查询 // 当调用exec的时候才真正执行查询 .skip((pageNum-1)*pageSize)//跳过指定的条数 .limit(pageSize)//限定返回的条数 .sort(&#123;age:1&#125;)//排序，按哪个字段排序，正序1还是倒序-1 .exec(function(err,docs)&#123;//执行查询 console.log(err) console.log(docs);// 7 8 9 &#125;) 12345服务器的实例是谁？？？ 集合（默认时候模块名字就是集合名字） 文档 数据库：201613node db 查询有什么数据库，当还没有数据库是是test use 201613node 切换数据库 db.users.insert(&#123;id:1,name:&apos;zfpx&apos;&#125;) 集合中插入 db.users.find() 集合中查找 123&lt;%- include ../includes/header.html%&gt; //头 //中间变的内容&lt;%- include ../includes/footer.html%&gt; //尾 123问题整理：__v什么意思update第三参数 &#123;multy:true&#125;甚意思mongoose.Promise = Promise;什么作用 12345678ls List all the registries current Show current registry name use &lt;registry&gt; Change registry to registry add &lt;registry&gt; &lt;url&gt; [home] Add one custom registry del &lt;registry&gt; Delete one custom registry home &lt;registry&gt; [browser] Open the homepage of registry with optional browser test [registry] Show response time for specific or all registries help Print this help 12dest上传的文件路径 通用中间件，不通用的renderflash里的消息一旦取值就销毁，一闪而过 数据库操作12使用数据库，切换数据库use 11111 （11111代表数据库的名字） 123查看所有数据库show dbs备注: 我们刚创建的数据库person 如果不在列表内， 要显示它，我们需要向 person 数据库插入一些数据 db.person.insert(&#123;name:&quot;zhangSan&quot;,age:30&#125;) 12查看当前使用的数据库db 或者 db.getName() 12删除数据库db.dropDatabase() 集合操作12查看帮助db.user.help() 12查看数据库下的集合show collections 12创建集合show collections","tags":[]},{"title":"gulp","date":"2016-11-16T17:08:58.000Z","path":"2016/11/17/gulp/","text":"gulp12npm install //项目依赖和安装依赖都安装npm install production //只安装项目依赖 1npm install gulp gulp-less gulp-concat gulp-uglify gulp-rename gulp-clean-css gulp-minify-html gulp-inject gulp-babel gulp-plumber gulp-connect gulp-load-plugins --save-dev gulp使用方法 1.全局安装gulp 2.在当前目录下创建一个gulp的配置文件gulpfile.js里面可以定义gulp任务 3.在命令行中执行gulp 任务名（如：gulp js） 1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);// var less = require(&apos;gulp-less&apos;);// var concat = require(&apos;gulp-concat&apos;);// var uglify = require(&apos;gulp-uglify&apos;);// var rename = require(&apos;gulp-rename&apos;);var $ = require(&apos;./gulp-load-plugins&apos;)();//相当于引入所有的依赖//定义一个JS任务gulp.task(&apos;js&apos;,function()&#123; // &#123;filename:&apos;a.js&apos;,content:&apos;a内容&apos;&#125; // &#123;filename:&apos;b.js&apos;,content:&apos;b内容&apos;&#125; gulp.src(&apos;./app/js/*.js&apos;) //把多个文件合并成一个文件并指定合并后的文件名 .pipe($.concat(&apos;all.js&apos;)) //再向硬盘保存一次 .pipe(gulp.dest(&apos;./build/js&apos;)) //文件夹名 //再压缩 .pipe($.uglify()) //再重命名 .pipe($.rename(&apos;all.min.js&apos;)) // 最后再保存一次 // &#123;filename:&apos;all.js&apos;,content:&apos;ab内容&apos;&#125; .pipe(gulp.dest(&apos;./build/js&apos;));&#125;); 安装babel1npm install babel-cli -g 使用预设 npm install babel-preset-es2015npm install babel-preset-es2016npm install babel-preset-vuenpm install babel-preset-react1234&lt;!-- .babelrc 文件中 --&gt;&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; reduce item为每一项 curr初始值为第二个参数的值12345678910111213141516171819var attrs = [1,2,3];var r = attrs.reduce(function(curr,item)&#123; console.log(&apos;item&apos;+item); console.log(&apos;curr&apos;+curr); console.log(curr*2 + item) return curr*2 + item;&#125;,0)console.log(r);&lt;!-- 输出结果 --&gt;item1curr01item2curr14item3curr41111 gulp npm install gulp –save-dev 通过require可以把gulp模块引入当前项目并赋值给gulp变量 这样gulp这个变量里面就会拥有gulp的所有的方法了1var gulp = require(&apos;gulp&apos;); gulp.task(参数1，参数2):创建一个任务123456789var gulp = require(&apos;gulp&apos;);/** * gulp.task(参数1，参数2):创建一个任务 * 1参数 是任务的名称 * 2参数 是任务定义函数 */gulp.task(&apos;hello&apos;,function()&#123; console.log(&apos;hello&apos;);&#125;); gulp.src(‘./app/index.html’)src得到的是一个可读流,获取到想要处理的文件流12gulp.src([&apos;./build/css/all.min.css&apos;,&apos;./build/js/all.min.js&apos;]);//数组gulp.src(&apos;./app/index.html&apos;);//字符串 123456789101112/** * src得到的是一个可读流 * 可读流里放的就不是单纯字节内容了，而是一个一个的对象 * &#123; * filename:&apos;文件名&apos;, * content:&apos;文件内容&apos; * &#125; */ gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;)); &#125;); gulp.dest(‘./build/index.html’) 复制1234gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;));&#125;); gulp.js工作方式12345gulp的使用流程一般是1.首先通过`gulp.src()`方法获取到想要处理的文件流2.然后把文件流通过pipe方法导入到gulp的插件中3.最后把经过插件处理后(把less文件转为css文件)的流再通过pipe方法导入到`gulp.dest()`中4.`gulp.dest()`方法则把流中的内容写入到文件中 12345gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.less&apos;]) .pipe(less()) .pipe(gulp.dest(&apos;./build/index.css&apos;));&#125;); watch监听1234567891011gulp.task(&apos;watch&apos;,function()&#123; &lt;!-- //当参数1发生改变时，调用copy和log任务 --&gt; gulp.watch(&apos;./app/*.html&apos;,[&apos;copy&apos;,&apos;log&apos;]);&#125;);gulp.task(&apos;watch&apos;,function()&#123; &lt;!-- //当参数1发生改变时，事件类型 --&gt; gulp.watch(&apos;./app/*.html&apos;,function(event)&#123; &lt;!-- type类型 1.added 2.deleted 3.changed --&gt; console.log(event); &#125;)&#125;); 事件类型，1.added（这个没有效果） 2.deleted 3.changed123&lt;!-- 修改文件内容 --&gt;&#123; type: &apos;changed&apos;, path: &apos;E:\\\\node课件\\\\2017.2.22\\\\app\\\\base.html&apos; &#125; 123&lt;!-- 删除文件 --&gt;&#123; type: &apos;deleted&apos;, path: &apos;E:\\\\node课件\\\\2017.2.22\\\\app\\\\44444.html&apos; &#125; api完成代码123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);/** * 1参数 是任务的名称 * 2参数 是任务定义函数 */gulp.task(&apos;hello&apos;,function()&#123; console.log(&apos;hello&apos;);&#125;);/** * src得到的是一个可读流 * 可读流里放的就不是单纯字节内容了，而是一个一个的对象 * &#123; * filename:&apos;文件名&apos;, * content:&apos;文件内容&apos; * &#125; */gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;));&#125;);gulp.task(&apos;log&apos;,function()&#123; console.log(&apos;log&apos;);&#125;)// type added deleted changed/*gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/*.html&apos;,[&apos;copy&apos;,&apos;log&apos;]); &#125;);*/gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/*.html&apos;,function(event)&#123; console.log(event); &#125;)&#125;); gulp插件：gulp提供了很多借口，但是本身并不能做太多的事情，其他实用的功能都是依靠插件来进行扩展的gulp-less插件可以把less文件编译成css .pipe(less()),里面没有参数 npm install gulp-less –save-dev1234567891011&lt;!-- css --&gt;var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;./app/less/*.less&apos;)//*******less .pipe(less()) .pipe(gulp.dest(&apos;./build/css&apos;));//*******css&#125;);gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/less/*.less&apos;,[&apos;css&apos;])&#125;) gulp-concat把几个文件合并到一块 npm install gulp-concat –save-dev123var concat = require(&apos;gulp-concat&apos;);//把多个文件合并成一个文件并指定合并后的文件名.pipe($.concat(&apos;all.js&apos;)) gulp-uglify对js文件进行压缩,此插件不能压缩es6，需要编译成es5在压缩 npm install gulp-uglify –save-dev12var uglify = require(&apos;gulp-uglify&apos;);.pipe($.uglify()) gulp-clean-css对css文件进行压缩 npm install gulp-clean-css –save-dev12var cleanCss = require(&apos;gulp-clean-css&apos;);.pipe($.cleanCss()) gulp-minify-html 对html文件进行压缩 npm install gulp-minify-html –save-dev12var minifyHtml = require(&apos;gulp-minify-html&apos;);.pipe($.minifyHtml()) gulp-rename在把处理好的文件存放的指定位置之前，我们可以先重命名一下它 npm install gulp-rename –save-dev1234var rename = require(&apos;gulp-rename&apos;);//再重命名为&apos;all.min.js&apos;&lt;!-- 可以为字符串 --&gt;.pipe($.rename(&apos;all.min.js&apos;)) 123456&lt;!-- 可以为函数 --&gt;.pipe($.rename(function(file)&#123; console.log(file) &lt;!-- &#123; dirname: &apos;.&apos;, basename: &apos;all&apos;, extname: &apos;.css&apos; &#125; --&gt; file.basename += &apos;.min&apos;;****** &#125;)) gulp-connect 有时候我们需要把文件放到本地服务器上去预览，他可以帮我们创建一个本地的服务器去运行我们的项目 npm install gulp-connect –save-dev12345678gulp.task(&apos;serve&apos;,function()&#123; //启动HTTP服务 $.connect.server(&#123; port:8080,//端口号 root:&apos;./build&apos;,//服务器的根目录 livereload:true//服务启动自动刷新 &#125;);&#125;); gulp-load-plugins自动加载所有的插件 npm install gulp-load-plugins –save-dev123var $ = require(&apos;gulp-load-plugins&apos;)();//再重命名为&apos;all.min.js&apos;.pipe($.rename(&apos;all.min.js&apos;)) gulp-babel:可以使用此插件吧es6的代码编译成es5代码 npm install gulp-babel –save1234567var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;js&apos;,function()&#123; gulp.src(&apos;./app/js/es6.js&apos;) .pipe($.babel(&#123;presets:[&quot;es2015&quot;]&#125;)) .pipe(gulp.dest(&apos;./build/js&apos;))&#125;); gulp-inject 动态自动插入生成后的js和css文件到html npm install gulp-inject –save-dev12345678910111213var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;html&apos;,function()&#123; //要插入的目标文件流 var target = gulp.src(&apos;./app/index.html&apos;); //将要被插入的资源 var source = gulp.src([&apos;build/css/all.min.css&apos;,&apos;build/js/all.min.js&apos;]); target //ignorePath:&apos;build&apos;:忽略build路径 //addRootSlash:false:是否添加跟斜线（/） .pipe($.inject(source,&#123;ignorePath:&apos;build&apos;,addRootSlash:false&#125;)) .pipe(gulp.dest(&apos;./build&apos;))&#125;); gulp-load-plugins实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- gulp-load-plugins实现原理 --&gt;/** * 1. 读取package.json文件的devDependencies配置项 * 2. 寻找gulp-开头的那些属性。 * 3. 加载这些模块，并把返回值挂到$的属性上(属性名就是模块名去掉gulp-,后面变成驼峰命名法) *//** * 1. 读取package.json文件的devDependencies配置项 * 2. 寻找gulp-开头的那些属性。 * 3. 加载这些模块，并把返回值挂到$的属性上(属性名就是模块名去掉gulp-,后面变成驼峰命名法) */function load() &#123; var $=&#123;&#125;; var package = require(&apos;./package.json&apos;); var dev = package.devDependencies; /*for(var key in dev)&#123; if(/^gulp-/.test(key))&#123; $[toKey(key)] = require(key); &#125; &#125;*/ Object.keys(dev).forEach(function(key)&#123; if(/^gulp-/.test(key))&#123; $[toKey(key)] = require(key); &#125; &#125;); console.log(Object.keys(dev)); &lt;!-- Object.keys(dev)是把dev对象的属性名转换为数组 [ &apos;gulp&apos;, &apos;gulp-babel&apos;, &apos;gulp-clean-css&apos;, &apos;gulp-concat&apos;, &apos;gulp-connect&apos;, &apos;gulp-inject&apos;, &apos;gulp-less&apos;, &apos;gulp-load-plugins&apos;, &apos;gulp-minify-html&apos;, &apos;gulp-plumber&apos;, &apos;gulp-rename&apos;, &apos;gulp-uglify&apos; ] --&gt; return $&#125;function toKey(key) &#123; return key.slice(5).replace(/-(\\w)/g, function () &#123; return arguments[1].toUpperCase(); &#125;)&#125;module.exports = load; Object.keys(dev)是把dev对象的属性名转换为数组123456789101112[ &apos;gulp&apos;, &apos;gulp-babel&apos;, &apos;gulp-clean-css&apos;, &apos;gulp-concat&apos;, &apos;gulp-connect&apos;, &apos;gulp-inject&apos;, &apos;gulp-less&apos;, &apos;gulp-load-plugins&apos;, &apos;gulp-minify-html&apos;, &apos;gulp-plumber&apos;, &apos;gulp-rename&apos;, &apos;gulp-uglify&apos; ] js1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);// var less = require(&apos;gulp-less&apos;);// var concat = require(&apos;gulp-concat&apos;);// var uglify = require(&apos;gulp-uglify&apos;);// var rename = require(&apos;gulp-rename&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();//定义一个JS任务gulp.task(&apos;js&apos;,function()&#123; // &#123;filename:&apos;a.js&apos;,content:&apos;a内容&apos;&#125; // &#123;filename:&apos;b.js&apos;,content:&apos;b内容&apos;&#125; gulp.src(&apos;./app/js/*.js&apos;) //把多个文件合并成一个文件并指定合并后的文件名 .pipe($.concat(&apos;all.js&apos;)) //再向硬盘保存一次 .pipe(gulp.dest(&apos;./build/js&apos;)) //再压缩 .pipe($.uglify()) //再重命名 .pipe($.rename(&apos;all.min.js&apos;)) // 最后再保存一次 // &#123;filename:&apos;all.js&apos;,content:&apos;ab内容&apos;&#125; .pipe(gulp.dest(&apos;./build/js&apos;));&#125;); css123456789101112131415161718192021222324var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();/** * 1. 把less编译成css * 2. 把多个CSS文件合并成同一个 * 3. 先保存一次压缩前的合并文件 * 4. 进行压缩 * 5. 对压缩后的文件进行重命名 * 6. 再保存一次 **/gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;./app/less/*.less&apos;) .pipe($.less()) .pipe($.concat(&apos;all.css&apos;)) .pipe(gulp.dest(&apos;./build/css&apos;)) .pipe($.cleanCss()) // all.css all.min.css .pipe($.rename(function(file)&#123; console.log(file) &lt;!-- &#123; dirname: &apos;.&apos;, basename: &apos;all&apos;, extname: &apos;.css&apos; &#125; --&gt; file.basename += &apos;.min&apos;;****** &#125;)) .pipe(gulp.dest(&apos;./build/css&apos;))&#125;); html1234567891011121314var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();/** * 1. 获取app下面的所有的html * 2. 对html文件进行压缩 * 3. 保存压缩后HTML文件 * * 只能匹配任意字符，但不能路径分隔符 * ** 可以匹配任意字符，包括路径分隔符 **/gulp.task(&apos;html&apos;,function()&#123; gulp.src(&apos;./app/**/*.html&apos;) .pipe($.minifyHtml()) .pipe(gulp.dest(&apos;./build&apos;));&#125;); server 实现自动刷新1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;html&apos;,function()&#123; gulp.src(&apos;./app/index.html&apos;).pipe(gulp.dest(&apos;./build&apos;)) //拷贝完成后通知浏览器自动刷新一下 .pipe($.connect.reload())&#125;);gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/index.html&apos;,[&apos;html&apos;]);&#125;);// /index.htmlgulp.task(&apos;serve&apos;,function()&#123; //启动HTTP服务 $.connect.server(&#123; port:8080, root:&apos;./build&apos;, //启动自动刷新 livereload:true &#125;);&#125;);//此任务依赖的其它任务 组合任务gulp.task(&apos;default&apos;,[&apos;serve&apos;,&apos;watch&apos;]);","tags":[]},{"title":"jQuery","date":"2016-04-16T17:08:58.000Z","path":"2016/04/17/jQuery/","text":"核心 找到所有p元素，并且这些元素都为div元素的子元素1$(&quot;div&gt;p&quot;) 设置页面背景 1$(document.body).css(&quot;background&quot;:&quot;red&quot;) 隐藏一个表单中所有元素 1$(myForm.elements).hide() 在文档的第一个表单中，查找所有单选按钮(即：type值为radio的input元素) 1$(&quot;input:radio&quot;,document.forms[0]) 在一个ajax返回的xml文档中，查找所有div元素 1$(&quot;div&quot;,xml.responseXML) 动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。 选择器 #id id选择器 12345678查找 ID 为&quot;myDiv&quot;的元素:$(&quot;#myDiv&quot;);得到的结果:[ &lt;div id=&quot;myDiv&quot;&gt;id=&quot;myDiv&quot;&lt;/div&gt; ]查找含有特殊字符的元素:$(&quot;#foo\\\\[bar\\\\]&quot;)得到的结果:[ &lt;span id=&quot;foo[bar]&quot;&gt;&lt;/span&gt;]$(&quot;#foo\\\\.bar&quot;)得到的结果:[ &lt;span id=&quot;foo.bar&quot;&gt;&lt;/span&gt;] element 元素选择器 12$(&quot;div&quot;);得到的结果:[ &lt;div&gt;DIV1&lt;/div&gt;, &lt;div&gt;DIV2&lt;/div&gt; ] .class 类选择器 12$(&quot;.myClass&quot;);得到的结果:[ &lt;div class=&quot;myClass&quot;&gt;div class=&quot;myClass&quot;&lt;/div&gt;, &lt;span class=&quot;myClass&quot;&gt;span class=&quot;myClass&quot;&lt;/span&gt; ] *通配符选择器 得到所有的标签元素 12$(&quot;*&quot;);得到的结果:[ &lt;div&gt;DIV&lt;/div&gt;, &lt;span&gt;SPAN&lt;/span&gt;, &lt;p&gt;P&lt;/p&gt; ] parent &gt; child,在给定的父元素下匹配所有的子元素; 123parent可以为任何有效选择器，child用以匹配元素的选择器，并且它是第一个选择器的子元素得到的结果只能是form选择器的子元素，同一级的元素和孙子级的都得不到[ &lt;input name=&quot;name&quot; /&gt; ] 1$(&quot;form &gt; input&quot;); prev + next,匹配所有紧接在 prev 元素后的 next 元素;12345678910111213prev任何有效选择器，next匹配一个选择器，并且紧接着第一个选择器&lt;!--&lt;form&gt; &lt;label&gt;Name:&lt;/label&gt; &lt;input name=&quot;name&quot; /&gt; &lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name=&quot;newsletter&quot; /&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;input name=&quot;none&quot; /&gt;--&gt;得到的结果：[ &lt;input name=&quot;name&quot; /&gt;, &lt;input name=&quot;newsletter&quot; /&gt; ] 1$(&quot;label+input&quot;) prev ~ siblings,匹配 prev 元素之后的所有 siblings 元素;123prev为任何有效元素，siblings为一个选择器，并且是第一个选择器的同辈得到的结果：[ &lt;input name=&quot;none&quot; /&gt; ] 1$(&quot;form~input&quot;); :first获取匹配的第一个元素 12$(&quot;li:first&quot;);得到的结果：[ &lt;li&gt;list item 1&lt;/li&gt; ] :not(selector)去除所有与给定选择器匹配的元素 123456&lt;!-- &lt;input name=&quot;apple&quot; /&gt; &lt;input name=&quot;flower&quot; checked=&quot;checked&quot; /&gt;--&gt;$(&quot;input:not(:checked)&quot;)查找所有未选中的 input 元素得到的结果：[ &lt;input name=&quot;apple&quot; /&gt; ] :even匹配所有索引值为偶数的元素，从0开始计数 12$(&quot;tr:even&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ] :odd匹配所有索引值为奇数的元素，从0开始计数 12$(&quot;tr:odd&quot;);得到的结果:[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :eq(index)匹配一个给定索引值的元素，index从0开始计数 12$(&quot;tr:eq(1)&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :gt(index)匹配所有大于给定索引值的元素，index从0开始计数 12$(&quot;tr:gt(0)&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ] :last获取匹配的最后一个元素 12$(&quot;tr:last&quot;)得到的结果：[ &lt;li&gt;list item 5&lt;/li&gt; ] :lt(index)获取所有小于给定索引值的元素 12$(&quot;tr:lt(2)&quot;)获取到的结果：[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :header 匹配如：h1,h2,h3之类的标题元素 12$(&quot;:header&quot;).css(&quot;background&quot;,&quot;#EEE&quot;)得到的结果：[ &lt;h1 style=&quot;background:#EEE;&quot;&gt;Header 1&lt;/h1&gt;, &lt;h2 style=&quot;background:#EEE;&quot;&gt;Header 2&lt;/h2&gt; ] :animated匹配所有正在执行动画效果的元素 123$(&quot;#run&quot;).click(function()&#123; $(&quot;div:not(:animated)&quot;).animate(&#123;left:&quot;+=20&quot;&#125;,1000);&#125;) 如果不确定返回的数据是jq对象还是js元素，可以alert一下，看返回的是object还是element，如果是object为jq元素，如果为element为js元素","tags":[]},{"title":"上传博客","date":"2016-02-16T17:08:58.000Z","path":"2016/02/17/post/","text":"npm node package mana 安装完node后自带送一个npm 安装前端包 bower 安装后台包 npm 切换源（nrm切换工具） 将下载的网址切换到珠峰(把外网切换为珠峰内网) 1npm config set registry &quot;http://172.18.0.199&quot; 全局安装本地安装 起到切换源的作用1npm install nrm -g 只在命令行下使用才加-g属性 显示所有源1nrm ls 使用源1nrm use taobao 添加珠峰源1nrm add zhufeng http://172.18.0.199 删除存在的源1nrm del zhufeng 测试网速1nrm test 搭建博客（自动生成 hexo） 唯一性 一个github账号只能有一个1npm install hexo-cli -g 生成博客12mkdir jwTest &amp;&amp;cd jwTesthexo init 启动服务1hexo server -p 5000 发布github(安装插件)12npm install hexo-deployer-git --save发布的时候不用输入账号密码 重新生成1hexo g 发布12hexo deploy第一次发布会生成.deploy_git文件 一些常用的命令1234567hexo new &quot;postName&quot; #新建文章 ..\\_posts\\222.mdhexo new page &quot;pageName&quot; #新建页面(文件夹) ..\\source\\1111\\index.mdhexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 静态页 gh-pagesgh-pages分支的名字，提供静态页的展示 初始化仓库git init 建立联系git remote add origin 创建并切换分支git checkout -b gh-pagh推送","tags":[]}]