[{"title":"Flex布局语法","date":"2017-04-13T19:10:45.106Z","path":"2017/04/14/flex/","text":"网页布局是css的一个重点应用。 布局的传统解决方案，基于盒子模型，依赖display属性+position属性+float属性。他对于那些特殊的布局非常不方便，比如：垂直居中就不容易实现。 2009年，w3c提出了一种新的方案——flex布局，可以简便、完整、响应式的实现各种页面布局。目前他已经得到了所以的浏览器的支持，这意味着，现在就能很安全的使用这项功能。 flex布局将成为未来布局的首选方案，一下介绍他的语法和常见布局的flex写法。 语法1.flex布局是什么？flex是flexible Box的缩写，意味着弹性布局，用来为盒子模型提供最大的灵活性。 任何一个容器都可以指定为flex布局。 123.box&#123; display:flex;&#125; 行内元素也可以使用flex布局 123.box&#123; display:inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234 .box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 2.基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 3.容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 3.1 flex-direction属性,决定主轴的方向（即项目的排列方向）。123 .box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123 .box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的内容对齐方式。123 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目(整个项目集合)在交叉轴上如何对齐。123 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。（交叉轴内容对齐方式，类似justify-content属性 ）123 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 4、项目的属性以下6个属性设置在项目上。 123456orderflex-growflex-shrinkflex-basisflexalign-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123 .item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123 .item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123 .item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 ===================================================================Flex布局实例你会看到，不管是什么布局，Flex往往都可以几行命令搞定。 1、骰子的布局骰子的一面，最多可以放置9个点。 下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到codepen查看Demo。 如果不加说明，本节的HTML模板一律如下。123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;&lt;/div&gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。 1.1 单项目 首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。123.box &#123; display: flex;&#125; 设置项目的对齐方式，实现居中对齐1234.box &#123; display: flex; justify-content: center;&#125; 设置项目的对齐方式，实现右对齐。1234.box &#123; display: flex; justify-content: flex-end;&#125; 设置交叉轴对齐方式，可以垂直移动主轴。1234.box &#123; display: flex; align-items: center; &#125; 12345.box &#123; display: flex; justify-content: center; align-items: center;&#125; 12345.box &#123; display: flex; justify-content: center; align-items: flex-end;&#125; 12345.box &#123; display: flex; justify-content: flex-end; align-items: flex-end;&#125; 1.2 双项目1234.box &#123; display: flex; justify-content: space-between;&#125; 12345.box &#123; display: flex; flex-direction: column; justify-content: space-between;&#125; 12345.box &#123; display: flex; flex-direction: column; justify-content: space-between;&#125; 123456.box &#123; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end;&#125; 123456.box &#123; display: flex;&#125;.item:nth-child(2) &#123; align-self: center;&#125; 1234567.box &#123; display: flex; justify-content: space-between;&#125;.item:nth-child(2) &#123; align-self: flex-end;&#125; 1.3 三项目123456789.box &#123; display: flex;&#125;.item:nth-child(2) &#123; align-self: center;&#125;.item:nth-child(3) &#123; align-self: flex-end;&#125; 1.4 四项目123456.box &#123; display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between;&#125; 12345678910111213141516171819202122HTML代码如下。 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 .box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125;.column &#123; flex-basis: 100%; display: flex; justify-content: space-between;&#125; 1.5 六项目12345.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125; 123456.box &#123; display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;&#125; 123456789101112131415161718192021222324252627282930HTML代码如下。 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 .box &#123; display: flex; flex-wrap: wrap;&#125;.row&#123; flex-basis: 100%; display:flex;&#125;.row:nth-child(2)&#123; justify-content: center;&#125;.row:nth-child(3)&#123; justify-content: space-between;&#125; 1.6 九项目1234.box &#123; display: flex; flex-wrap: wrap;&#125; 2、网格布局2.1 基本网格布局 最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。12345678910111213HTML代码如下。 &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;&lt;/div&gt; CSS代码如下。 .Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125; 2.2 百分比布局 某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。123456789101112131415161718192021222324HTML代码如下。 &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot;&gt;...&lt;/div&gt;&lt;/div&gt; .Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125;.Grid-cell.u-full &#123; flex: 0 0 100%;&#125;.Grid-cell.u-1of2 &#123; flex: 0 0 50%;&#125;.Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%;&#125;.Grid-cell.u-1of4 &#123; flex: 0 0 25%;&#125; 3、圣杯布局圣杯布局（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647HTML代码如下。 &lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 .HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;header,footer &#123; flex: 1;&#125;.HolyGrail-body &#123; display: flex; flex: 1;&#125;.HolyGrail-content &#123; flex: 1;&#125;.HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em;&#125;.HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1;&#125; 如果是小屏幕，躯干的三栏自动变为垂直叠加。 @media (max-width: 768px) &#123; .HolyGrail-body &#123; flex-direction: column; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content &#123; flex: auto; &#125;&#125; ４、输入框的布局我们常常需要在输入框的前方添加提示，后方添加按钮。12345678910111213HTML代码如下。 &lt;div class=&quot;InputAddOn&quot;&gt; &lt;span class=&quot;InputAddOn-item&quot;&gt;...&lt;/span&gt; &lt;input class=&quot;InputAddOn-field&quot;&gt; &lt;button class=&quot;InputAddOn-item&quot;&gt;...&lt;/button&gt;&lt;/div&gt; CSS代码如下。 .InputAddOn &#123; display: flex;&#125;.InputAddOn-field &#123; flex: 1;&#125; 5、悬挂式布局有时，主栏的左侧或右侧，需要添加一个图片栏。 12345678910111213141516HTML代码如下。 &lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt;&lt;/div&gt; CSS代码如下。 .Media &#123; display: flex; align-items: flex-start;&#125;.Media-figure &#123; margin-right: 1em;&#125;.Media-body &#123; flex: 1;&#125; 6、固定的底栏有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。123456789101112131415HTML代码如下。 &lt;body class=&quot;Site&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 .Site &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;.Site-content &#123; flex: 1;&#125; 7、流式布局每行的项目数固定，会自动分行。 12345678910111213141516CSS的写法。 .parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;&#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;&#125; 转载自阮老师博客","tags":[]},{"title":"git分支","date":"2017-04-12T06:02:55.753Z","path":"2017/04/12/git/","text":"查看所在的分支1git branch 查看所有的分支1git branch -a 切换分支1git checkout gh-pages 上传12git add .git commit -m&quot;1&quot; 推送到分支1git push origin gh-pages","tags":[]},{"title":"ES6箭头函数和function","date":"2017-04-06T15:56:01.556Z","path":"2017/04/06/箭头函数/","text":"JavaScript ES6箭头函数指南胖箭头函数（Fatarrowfunctions），又称箭头函数，是一个来自ECMAScript2015（又称ES6）的全新特性。有传闻说，箭头函数的语法=&gt;，是受到了CoffeeScript的影响，并且它与CoffeeScript中的=&gt;语法一样，共享this上下文。 箭头函数的产生，主要由两个目的：更简洁的语法和与父作用域共享关键字this。接下来，让我们来看几个详细的例子。新的函数语法传统的JavaScript函数语法并没有提供任何的灵活性，每一次你需要定义一个函数时，你都必须输入function(){}。CoffeeScript如今之所以那么火，有一个不可忽略的原因就是它有更简洁的函数语法。更简洁的函数语法在有大量回调函数的场景下好处特别明显，让我们从一个Promise链的例子看起：1234567function getVerifiedToken(selector)&#123; return getUsers(selector) .then(function(users)&#123;returnusers[0];&#125;) .then(verifyUser) .then(function(user,verifiedToken)&#123;returnverifiedToken;&#125;) .catch(function(err)&#123;log(err.stack);&#125;);&#125; 以下是使用新的箭头函数语法进行重构后的代码：1234567functiongetVerifiedToken(selector)&#123; return getUsers(selector) .then(users=&gt;users[0]) .then(verifyUser) .then((user,verifiedToken)=&gt;verifiedToken) .catch(err=&gt;log(err.stack));&#125; 以下是值得注意的几个要点：function和{}都消失了，所有的回调函数都只出现在了一行里。当只有一个参数时，()也消失了（rest参数是一个例外，如(…args)=&gt;…）。当{}消失后，return关键字也跟着消失了。单行的箭头函数会提供一个隐式的return（这样的函数在其他编程语言中常被成为lamda函数）。这里再着重强调一下上述的最后一个要求。仅仅当箭头函数为单行的形式时，才会出现隐式的return。当箭头函数伴随着{}被声明，那么即使它是单行的，它也不会有隐式return：1234567const getVerifiedToken=selector=&gt;&#123; return getUsers() .then(users=&gt;users[0]) .then(verifyUser) .then((user,verifiedToken)=&gt;verifiedToken) .catch(err=&gt;log(err.stack));&#125; 如果我们的函数内只有一条声明（statement），我们可以不写{}，这样看上去会和CoffeeScript中的函数非常相似：123456const getVerifiedToken=selector=&gt;getUsers().then(users=&gt;users[0]).then(verifyUser).then((user,verifiedToken)=&gt;verifiedToken).catch(err=&gt;log(err.stack)); 你没有看错，以上的例子是完全合法的ES6语法。当我们谈论只包含一条声明（statement）的箭头函数时，这并不意味着这条声明不能够分成多行写。 这里有一个坑，当忽略了{}后，我们该怎么返回空对象（{}）呢？12const emptyObject=()=&gt;&#123;&#125;;emptyObject();//? 不幸的是，空对象{}和空白函数代码块{}长得一模一样。。以上的例子中，emptyObject的{}会被解释为一个空白函数代码块，所以emptyObject()会返回undefined。如果要在箭头函数中明确地返回一个空对象，则你不得不将{}包含在一对圆括号中(({}))：12const emptyObject=()=&gt;(&#123;&#125;);emptyObject();//&#123;&#125; 下面是一个更完整的例子：1234567891011121314function()&#123;return 1;&#125;()=&gt;&#123;return 1;&#125;()=&gt;1function(a)&#123;return a*2;&#125;(a)=&gt;&#123;return a*2;&#125;(a)=&gt;a*2a=&gt;a*2function(a,b)&#123;return a*b;&#125;(a,b)=&gt;&#123;return a*b;&#125;(a,b)=&gt;a*bfunction()&#123;return arguments[0];&#125;(...args)=&gt;args[0]()=&gt;&#123;&#125;//undefined()=&gt;(&#123;&#125;)//&#123;&#125; this:JavaScript中this的故事已经是非常古老了，每一个函数都有自己的上下文。以下例子的目的是使用jQuery来展示一个每秒都会更新的时钟：12345$(&apos;.current-time&apos;).each(function()&#123; setInterval(function()&#123; $(this).text(Date.now()); &#125;,1000);&#125;); 当尝试在setInterval的回调中使用this来引用DOM元素时，很不幸，我们得到的只是一个属于回调函数自身上下文的this。一个通常的解决办法是定义一个that或者self变量：123456$(&apos;.current-time&apos;).each(function()&#123; var self=this; setInterval(function()&#123; $(self).text(Date.now()); &#125;,1000);&#125;); 但当使用胖箭头函数时，这个问题就不复存在了。因为它不产生属于它自己上下文的this：123$(&apos;.current-time&apos;).each(function()&#123; setInterval(()=&gt;$(this).text(Date.now()),1000);&#125;); arguments变量箭头函数与普通函数还有一个区别就是，它没有自己的arguments变量：12345function log(msg)&#123; const print=()=&gt;console.log(arguments[0]); print(`LOG:$&#123;msg&#125;`);&#125;log(&apos;hello&apos;);//hello 再次重申，箭头函数没有属于自己的this和arguments。但是，你仍可以通过rest参数，来得到所有传入的参数数组：12345function log(msg)&#123; const print=(...args)=&gt;console.log(args[0]); print(`LOG:$&#123;msg&#125;`);&#125;log(&apos;hello&apos;);//LOG:hello 箭头函数不能作为generator函数使用。","tags":[]},{"title":"如何创建对象？","date":"2017-04-05T07:46:11.514Z","path":"2017/04/05/创建对象方法/","text":"一字面量1234567891011var对象名=&#123;属性名1：属性值,属性名2：属性值,函数名1:function(形参......)&#123;函数体1&#125;,函数名2:function(形参......)&#123;函数体2&#125;,&#125;;var zjl=&#123; name:&quot;周杰伦&quot;, gender:&quot;male&quot;, setAge:function(age)&#123;this.curage=age;&#125;&#125;; 实例12345var对象名=newObject();varzjl=newObject();zjl.name=&quot;周杰伦&quot;;zjl.gender=&quot;male&quot;;zjl.setAge=function(age)&#123; this.curage=age;&#125;; 二1.工厂模式function person(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () { alert(this.name) } return o; } var person1 = person(‘Nicholas’,22, ‘Software Engineer’); 2.构造函数模式function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { alert(this.age) } } var person2 = new Person(&apos;Nicholas&apos;, 22, &apos;Software Engineer&apos;); 3.原型模式function Person() { } Person.prototype.name = &apos;Nicholas&apos;; Person.prototype.age = 22; Person.prototype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function () { alert(this.name) } var person3 = new Person(); 3.1更简单的原型方法function Person() { } Person.prototype = { name : &apos;Nicholas&apos;, sge:22, job:&apos;Software Engineer&apos;, sayName:function () { alert(this.name) } } var person3 = new Person(); 4.组合使用构造函数和原型模式(也是最常用的方法)function PersonPrototype(name, age, job) { this.name = name; this.age = age; this.job = job; } Person.prototype.sayName = function () { alert(this.name) } var person4 = new Person(‘Nicholas’, 22, ‘Software Engineer’) 5.动态原型模式function person() { //属性 this.name = name; this.age = age; this.job = job; //方法 if(typeof this.sayName != &quot;function&quot;){ Person.prototype.sayName = function () { alert(this.name) } } } var person5 = new Person(‘Nicholas’, 22, ‘Software Engineer’) 6.寄生构造函数模式function Person(name, sge, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () { alert(this.name) } return o ; } var person6 = new Person(‘Nicholas’, 22, ‘Software Engineer’); 7.稳妥构造函数function person (name, age, job) { //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayname = function () { alert(name) } return o ; } var person7 = new Person(‘Nicholas’, 22, ‘Software Engineer’);","tags":[]},{"title":"前端Js框架汇总","date":"2017-04-05T00:59:53.797Z","path":"2017/04/05/前端Js框架汇总/","text":"一、前端框架库：1.Zepto.js地址：http://www.css88.com/doc/zeptojs/ 描述：Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。关于Zepto认知我也是通过与一位腾讯朋友聊天的时候知道的，只作了些基础的了解。 2.SUI Mobile地址：http://m.sui.taobao.org 描述：SUI Mobile 是一套基于 Framework7 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。用途：你也看到了，他是用于无线端的Web App的开发。 3.Node.Js地址：http://www.runoob.com/nodejs/nodejs-tutorial.html (中文网) 描述：Node.js是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。 Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 用途：1. RESTful API 这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。 2. 统一Web应用的UI层 目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。 不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。 3. 大量Ajax请求的应用例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。 总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。 4.angular.Js地址：http://www.runoob.com/angularjs/angularjs-tutorial.html (中文网) 描述：AngularJS[1] 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。用途：通过描述我们应该就能很好的明白AngularJS的真实用途了，MVVM，模块化，自动化双向数据绑定等等。除了简单的dom操作外，更能体现Js编程的强大。当然应用应该视场合而定。 5.JQuery Mobile地址：http://www.w3school.com.cn/jquerymobile/ (中文网) 描述：Query Mobile是jQuery 在手机上和平板设备上的版本。jQuery Mobile 不仅会给主流移动平台带来jQuery核心库，而且会发布一个完整统一的jQuery移动UI框架。支持全球主流的移动平台。jQuery Mobile开发团队说：能开发这个项目，我们非常兴奋。移动Web太需要一个跨浏览器的框架，让开发人员开发出真正的移动Web网站。 用途：jQuery Mobile 是创建移动 web 应用程序的框架。 jQuery Mobile 适用于所有流行的智能手机和平板电脑。 jQuery Mobile 使用 HTML5 和 CSS3 通过尽可能少的脚本对页面进行布局。 6.requirejs地址：http://www.requirejs.cn/ 描述：RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。RequireJS以一个相对于baseUrl的地址来加载所有的代码。 页面顶层script标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。 用途：模块化动态加载。 7.Vue.js地址：http://cn.vuejs.org/ 描述：Vue.js 是用于构建交互式的 Web 界面的库。它提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。从技术上讲， Vue.js 集中在 MVVM 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象出来成指令和过滤器。相比其它的 MVVM 框架，Vue.js 更容易上手。 8.backbone.js地址：http://www.css88.com/doc/backbone/ 描述：Backbone 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESTful JSON接口连接到应用程序。 9.React地址：http://reactjs.cn/react/docs/why-react.html 描述：React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库。很多人认为 React 是 MVC 中的 V（视图）。我们创造 React 是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。为了达到这个目标，React 采用下面两个主要的思想。 10.Ionic地址：http://www.ionic.wang/js_doc-index.html 描述：Ionic既是一个CSS框架也是一个Javascript UI库。许多组件需要Javascript才能产生神奇的效果，尽管通常组件不需要编码，通过框架扩展可以很容易地使用，比如我们的AngularIonic扩展。Ionic遵循视图控制模式，通俗的理解和 Cocoa 触摸框架相似。在视图控制模式中，我们将界面的不同部分分为子视图或包含其他视图的子视图控制器。然后视图控制器“驱动”内部视图来提供交互和UI功能。一个很好的例子就是标签栏（Tab Bar）视图控制器处理点击标签栏在一系列可视化面板间切换。 浏览我们的API文档来了解视图控制器和Ionic中可用的Javascript实用工具。 Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它 提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。 二、前端UI框架1.Pure地址：http://purecss.org/layouts/ 描述：Pure精心设计，只为可以在任何Web项目中使用。为了例证这一点，我们制作了如下几个模板。这些模板都是响应式的，并且没有使用任何JavaScript。 用途：真的是很精美的一个样式框架，便于我们快事构建一些个人产品，当然也可以服务于工作中的一些项目。 2.bootstrap地址：http://www.bootcss.com/ 描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 3.EasyUI地址：http://www.jeasyui.net/ (中文网) 描述：easyui是一种基于jQuery的用户界面插件集合。 easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。 使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。 easyui是个完美支持HTML5网页的完整框架。 easyui节省您网页开发的时间和规模。 easyui很简单但功能强大的。 4.Ant Design地址：http://ant.design/ 描述：一个 UI 设计语言，一套提炼和应用于企业级后台产品的交互语言和视觉体系 三、可视化组件1.Echarts地址：http://echarts.baidu.com/ 描述：ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 2.tableau(收费)地址：http://www.yuandingit.com/special/tableau/index.html 描述：Tableau 是桌面系统中最简单的商业智能工具软件，Tableau 没有强迫用户编写自定义代码，新的控制台也可完全自定义配置。在控制台上，不仅能够监测信息，而且还提供完整的分析能力。Tableau控制台灵活，具有高度的动态性。 四、前端构建工具1.gulp地址：https://zhangyunyan.github.io/2016/11/17/gulp/描述：易于使用 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质 Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 五、博客搭建1.技术组合 HEXO+Github,搭建属于自己的博客。 站点：https://zhangyunyan.github.io/2016/02/17/post/ HEXO介绍：Hexo是一个开源的静态博客生成器,用node.js开发,作者是台湾大学生tommy351 准备：git + node.js + markdown编辑 + gitcafe + 域名","tags":[]},{"title":"谈谈我理解的前端","date":"2017-04-01T13:54:56.891Z","path":"2017/04/01/谈谈我理解的前端/","text":"谈谈我理解的前端：这是我个人对前端的一些理解及看法，可能理解得不太到位，前端主要包括三门技术html、css及javascript(下称js)，其中以js为主为难。js很早就有了，开始的时候，还伴随着vbscript，死敌有applet(java的一种小程序),那时候，玩js的人会被其它编程的人看得很轻，觉得那不过是一种不完善的脚本语言，所以开始的时候用的并不多，特效什么的一般都applet来完成。 1998年，js的旁肢ajax延生，开始几年知道的人还不多，过了几年后，人们发现ajax的无刷新交互效果很不错，当时还有相当一部份人觉得ajax是一门新的技术，做一网站，用ajax的和不用ajax的是截然的两种价位。用ajax，就必须涉及到js，这就引起了学js的热潮，个人觉得国内应该比较晚一点，估摸是在2004、2005年左右才掀起的热潮，到2008年，一个新的时尚职位名诞生：web前端！ 下面说说我对学js的一点看法： 现在js框架很多，比如jquery、extjs等等，应该有尽有。但我觉得，学技术，最好从底层学起。一是底层技术学好了，扩展的技术自然容易学到手。比如，你js很好，学jquery自然快，甚至不用学，看手册就大概明其理，用起来也不在话下。二是，如先学框架，因为框架将底层的东西都封装好了，用起来会觉得好用，也不怎么用动脑子去理解什么原理，拿来就用，容易形成一种依赖性，到后面，发明自己有些东西不太能理解，又想看底层的东西，觉得自己忽然就很弱，心情波动太多，就不易再专心学底层的东西了，可能也学不进去了。还有，学框架的东西，也就是学用人家设计好的方法，比如jquery的bind()方法，开始的版本都是这个，用来绑定事件，本人没深入了解过从哪个版本开始，建议用新的方法on()——还其它方法类似这改动，说这个是想说明，人家写的方法，你是永远学不完的，人家一改版一改动，你就得从头再学了，也就是被人家牵着走，还是底层的东西，基本上千百年都不会变。还有，jquery的fn(原型)扩展看上去是很好用，但是，fn太多，jquery就很臃肿，每个html元素也同样变得臃肿，效率不言而预了。 再有，当你用了jquery多年后，IE7已经灭绝了，到时就可以用Element对象扩展了，新的框架可能就占先机取代了jquery，就算没取代，那jquery就得重整，不整跟不上时代的脚步，那很多方法可能就得改了，改了又得重学了（好不容易用熟练了），等这个用熟练了，可能那时的浏览器都支持HTMLElement扩展了，又更精确了，jquery又。。。所以，我还是建议学底层得好，当然，最后的选择是你自己决定的。 最后，html5也如火如荼了，其中很多东西是跟后台相关的，比如localStorage啊，WebSocket，还有其它的很多（包括非html5的ajax)，所以，学一门后台技术，是前端走得更好的垫脚石。 既然提到html5了，大伙就很容易想到绘图canavs了，在些给大伙讲几个可能大家有点模糊的方法（以下方法是用本人自己的口头语阐述，可能跟书本说的不太一样，只是方便大家理解，所以，看了不太适应的同学，不要用语言来打击我）。 前端，是一门说难不难，说容易也不容易的技术。就是多看多练多动脑！","tags":[]},{"title":"less及less编译","date":"2017-04-01T13:13:31.951Z","path":"2017/04/01/less/","text":"HTML和CSS不属于编程语言而是属于标记语言，所以很难像JS一样定义变量、编写方法、实现模块化开发等。 目前的CSS编写模式中，都是定义一些公共的样式类名，哪一块的HTML需要这个样式，就去增加对应的样式类名，所以我们经常看到一个标签上存在很多样式类名，在这种模式中我们要时常关注CSS的优先级，避免样式的重叠覆盖… 为了解决CSS的这一困境，CSS预处理预编译的思想脱颖而出，比较具有代表性的有LESS、SASS、Stylus。它们在传统的CSS基础上增加了大量的新的语法，编写方式，常用的函数等，可以让我们的CSS像JS一样成为一门编程语言。基于LESS我么可以把一些经常用到的样式定义成变量或者函数，以后需要直接的调取使用即可，这样不仅有利于增加我们的开发速度，也有利于项目的后期维护与可复用性。 LESS LESS是一门CSS预处理语言，它扩展了CSS语言，增加了变量、Mixin、函数等特性，使CSS更易维护和扩展。使用LESS基本上按照这样的步骤：编写LESS代码，使用NODE、JS或者是其他的工具把编写的LESS代码编译成我们平时看到的CSS代码(因为浏览器是无法解析LESS的语法的，所以编写完成的LESS代码需要进行编译)。 案例1:在传统的CSS编写中，我们事先为一个盒子.box编写了一套样式，当鼠标滑过的时候，让盒子在原有样式的部分颜色值上发生改变，里面的DIV标签的阴影颜色变重，这样的话我们需要把之前的样式拿过来写一遍，只是调整一下透明度或者颜色值而已，页面中的冗余代码比较的多，也不方便后期的维护。123456789101112131415161718.box &#123; color: #f938ab; border-color: #fdcdea;&#125;.box1 div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;//-&gt;在:hover触发的时候需要把上述的样式copy一份,在原来的基础上改变部分颜色值和透明度.box:hover &#123; color: #fe33ac;&#125;.box:hover div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);&#125; 如果我们使用的是LESS，那么我们可以节省很多的工作，也可以实现可扩展性和通用性，看下面的LESS代码：12345678910111213141516171819202122232425262728//-&gt;定义变量存储颜色值@color: #f938ab;//-&gt;你可以把它理解为JS中的一个函数.box-shadow(@style, @alpha:50%) &#123; -webkit-box-shadow: @style rgba(0, 0, 0, @alpha); -moz-box-shadow: @style rgba(0, 0, 0, @alpha); -ms-box-shadow: @style rgba(0, 0, 0, @alpha); -o-box-shadow: @style rgba(0, 0, 0, @alpha); box-shadow: @style rgba(0, 0, 0, @alpha);&#125;.box &#123; color: @color; border-color: #fdcdea; //-&gt;嵌套: 代表是 .box div div &#123; .box-shadow(0 0 5px, 30%); &#125; //-&gt;代表的是 .box:hover &amp;:hover &#123; //-&gt;saturate: LESS提供的颜色处理方法(还有很多其它的方法),用来调整颜色的饱和度变化 color: saturate(@color, 5%); //-&gt;嵌套: 代表是 .box:hover div div &#123; .box-shadow(0 0 5px); &#125; &#125;&#125; 通过NODE编译后的结果为：12345678910111213141516171819202122.box &#123; color: #f938ab; border-color: #fdcdea;&#125;.box div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;.box:hover &#123; color: #fe33ac;&#125;.box:hover div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);&#125; 大家感受一下，是不是感觉LESS很强大，一方面不仅仅让我们少些了很多的代码，而且我们定义的变量或者“函数”具有很强的公用性，以后其他的结构需要这样的样式，我们直接的调取就好了。既然认识到了LESS的强大，那么我们接下来就一步步的学会LESS的使用。 LESS的编译上述我们提到，编写完成的LESS代码是不能直接在浏览器中运行的，需要编译成正常的CSS代码。那么我们首先就来学习一下常用的LESS编译方式。 1、在浏览器中调用LESS.JSLESS只支持在现代浏览器中运行（最新版本的Chrome, Firefox, Safari 和 IE）。我们不建议在生产环境中使用LESS客户端，因为在将LESS编译成CSS的时候，用户会看到加载延迟的现象，即便在浏览器中有不足一秒的加载延迟，但也会降低性能。 首先引入我们设置样式的LESS文件，注意：这里的rel=’stylesheet/less’1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet/less&quot; href=&quot;1.less&quot;/&gt; 其次为了方便开发过程中的调试(上线后我们也可以配置一些必要的参数)，我们可以在引入LESS.JS之前设置一些配置的参数。我们一般都把所有的配置参数放在全局变量less中。 12345678910111213141516171819//-&gt;在引入LESS之前设置一个全局的变量less,配置一些参数值(根据情况自行选择需要配置的项)var less = &#123; //-&gt;evn:设置运行的环境(生产模式还是开发模式) //production:编译后的CSS缓存到本地localStorage中 //development:没有把编译后的CSS缓存到本地,在URL不是标准的格式下(例如:file://...),自动设置为development env: &quot;development&quot;, //-&gt;logLevel:javascript控制台日志量 logLevel: 2, //-&gt;async:同步或者异步导入文件,默认是false代表同步 async: false, //-&gt;fileAsync:使用文件协议访问页面时异步加载导入的文件,默认是false,如有需要设置为true fileAsync: false, //-&gt;poll:在监视模式下，每两次请求之间的时间间隔(ms) poll: 1000, //-&gt;dumpLineNumbers:当设置dumpLineNumbers直接输出源行信息到编译好的CSS的文件中时，有利于你调试指定行。comments参数用于输出用户可以理解的内容，而mediaQuery使用Firefox一个扩展来解析CSS和抽取信息。 dumpLineNumbers: &quot;comments&quot;, //-&gt;relativeUrls：是否调整相对路径。如果为false，则url已经是相对于入口的LESS文件。 relativeUrls: false&#125;; //-&gt;还有其它的参数,自己下去后可以再进行扩展 然后引入我们的less.js(下载less.js)1&lt;script type=&quot;text/javascript&quot; src=&quot;less.js&quot;&gt; &lt;/script&gt; 最后开启监视模式后,只要我们的LESS改变，在一定时间内，浏览器就会重新的编译，我们可以看到想要的效果12//-&gt;启用监视模式(env必须要设置成development) less.watch(); 2、使用NODE命令编译LESS这种方式是目前项目中最常用的方式，也是我推荐大家使用的方式，它是把我们的LESS文件编译成CSS文件，我们项目中直接的引入CSS文件即可，基本步骤：安装-&gt;编译/压缩编译-&gt;或者使用NODE代码实现批量编译等 把LESS模块安装到全局NODE环境中 1npm install less -g 使用命令进行编译 1234//-&gt;把styles.less文件编译成styles.css文件(如果没有这个CSS文件自己会创建)lessc styles.less styles.css//-&gt;编译完成的CSS文件是经过压缩的lessc styles.less styles.min.css -x或者--compress 如果你想要更牛X的压缩,还可以自己单独的设定,下面我们使用–clean-css。这个需要提前的安装less-plugin-clean-css模块才可以。1234//-&gt;安装less-plugin-clean-cssnpm install -g less-plugin-clean-css//-&gt;安装成功后就可以使用它压缩了lessc --clean-css styles.less styles.min.css 3、在NODE环境中编写批量编译的代码我们在上述用NODE命令编译的时候，一次只能编译一个文件，这样，如果页面中有多个LESS，每一次编译都是比较耗费时间的，所以我们结合NODE的FS文件读写操作，可以写一套批量编译的代码。12345678910111213141516171819//-&gt;定义编译文件目录和目标导出目录var dirPath = &quot;./less/&quot;, tarPath = &quot;./css/&quot;;//-&gt;导入NODE中需要使用的模块var fs = require(&quot;fs&quot;), less = require(&quot;less&quot;);//-&gt;读取dirPath中的所有文件,检查文件的类型,只有LESS文件我们才进行存储var ary = [],files = fs.readdirSync(dirPath);files.forEach(function (file, index) &#123; /\\.(LESS)/i.test(file) ? ary.push(file) : null;&#125;);//-&gt;把目录下的所有文件进行编译,把编译完成的结果保存在指定的目录中ary.forEach(function (file) &#123; var newFile = file.replace(&quot;.less&quot;, &quot;.css&quot;), conFile = fs.readFileSync(dirPath + file, &quot;utf-8&quot;);less.render(conFile, &#123;compress: true&#125;, function (error, output) &#123; fs.writeFileSync(tarPath + newFile, output.css, &quot;utf-8&quot;); &#125;);&#125;); 4、使用工具编译LESS目前常用的编译工具有：Koala(据说目前最流行的)、在线编译(http://tool.oschina.net/less)、SimpLESS等。关于工具的使用，自己下去下载研究即可，非常的简单，本篇文章不做过多的说明。 【转自珠峰培训】","tags":[]},{"title":"问题整理","date":"2017-03-30T08:17:55.320Z","path":"2017/03/30/前端面试题整理/","text":"目录$HTML，HTTP，web综合问题整理123456789101112131415161718192021221、前端需要注意哪些SEO2、&lt;img&gt;的title和alt有什么区别3、HTTP的几种请求方法用途4、从浏览器地址栏输入url到显示页面的步骤5、如何进行网站性能优化6、HTTP状态码及其含义7、语义化的理解8、介绍一下你对浏览器内核的理解9、html5有哪些新特性、移除了那些元素？10、HTML5的离线储存怎么使用，工作原理能不能解释一下？11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢12、请描述一下 cookies，sessionStorage 和 localStorage 的区别13、iframe有那些缺点？14、WEB标准以及W3C标准是什么?15、xhtml和html有什么区别?16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？18、HTML全局属性(global attribute)有哪些19、Canvas和SVG有什么区别？20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？21、如何在页面上实现一个圆形的可点击区域？22、网页验证码是干嘛的，是为了解决什么安全问题 $CSS部分12345678910111213141516171819202122232425261、css sprite是什么,有什么优缺点2、display: none;与visibility: hidden;的区别3、link与@import的区别4、什么是FOUC?如何避免5、如何创建块级格式化上下文(block formatting context),BFC有什么用7、清除浮动的几种方式，各自的优缺点8、为什么要初始化CSS样式?9、css3有哪些新特性10、display有哪些值？说明他们的作用11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？12、CSS优先级算法如何计算？13、对BFC规范的理解？14、谈谈浮动和清除浮动15、position的值， relative和absolute`定位原点是16、display:inline-block 什么时候不会显示间隙？(携程)17、PNG,GIF,JPG的区别及如何选18、行内元素float:left后是否变为块级元素？19、在网页中的应该使用奇数还是偶数的字体？为什么呢？20、::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）22、CSS合并方法23、CSS不同选择器的权重(CSS层叠的规则)24、列出你所知道可以改变页面布局的属性25、CSS在性能优化方面的实践26、CSS3动画（简单动画的实现，如旋转等）27、base64的原理及优缺点 $JavaScript12345678910111213141516171819202122232425262728293031323334353637383940414243444546471、闭包2、说说你对作用域链的理解3、JavaScript原型，原型链 ? 有什么特点？4、请解释什么是事件代理5、Javascript如何实现继承？6、谈谈This对象的理解7、事件模型8、new操作符具体干了什么呢?9、Ajax原理11、模块化开发怎么做？12、异步加载JS的方式有哪些？13、那些操作会造成内存泄漏？14、XML和JSON的区别？15、谈谈你对webpack的看法17、常见web安全及防护原理18、用过哪些设计模式？19、为什么要有同源限制？20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别21、javascript有哪些方法定义对象22、常见兼容性问题？22、说说你对promise的了解23、你觉得jQuery源码有哪些写的好的地方25、Node的应用场景26、谈谈你对AMD、CMD的理解27、那些操作会造成内存泄漏？28、web开发中会话跟踪的方法有哪些29、介绍js的基本数据类型30、介绍js有哪些内置对象？31、说几条写JavaScript的基本规范？32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？33、javascript创建对象的几种方式？34、eval是做什么的？35、null，undefined 的区别？36、[“1”, “2”, “3”].map(parseInt) 答案是多少？37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？38、JSON的了解？39、js延迟加载的方式有哪些？40、同步和异步的区别?41、渐进增强和优雅降级42、defer和async43、说说严格模式的限制44、attribute和property的区别是什么？45、谈谈你对ES6的理解46、ECMAScript6 怎么写class么，为什么会出现class这种东西?47、什么是面向对象编程及面向过程编程，它们的异同和优缺点48、从你自己的理解来看，你是如何理解面向对象编程的，它解决了什么问题，有什么作用49、对web标准、可用性、可访问性的理解 $编程题123451、写一个通用的事件侦听器函数2、如何判断一个对象是否为数组3、冒泡排序4、快速排序5、编写一个方法 求一个字符串的字节长度 $其他123451、谈谈你对重构的理解2、什么样的前端代码是好的3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？4、你觉得前端工程的价值体现在哪5、平时如何管理你的项目？ 人事面123456789面试完你还有什么问题要问的吗你有什么爱好?你最大的优点和缺点是什么?你为什么会选择这个行业，职位?你觉得你适合从事这个岗位吗?你有什么职业规划?你对工资有什么要求?如何看待前端开发？未来三到五年的规划是怎样的？ 常问1234567自我介绍你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？你认为哪个项目做得最好？最近在看哪些前端方面的书？平时是如何学习前端开发的？你最有成就感的一件事你是怎么学习前端的 解答$HTML， HTTP，web综合问题1、前端需要注意哪些SEO1234567合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用js输出：爬虫不会执行js获取内容少用iframe：搜索引擎不会抓取iframe中的内容非装饰性图片必须加alt提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、img标签的title和alt有什么区别12通常当鼠标滑动到元素上的时候显示alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTTP的几种请求方法用途1234567891011121314151617181920212223241、GET方法发送一个请求来取得服务器上的某一资源2、POST方法向URL指定的资源提交数据或附加新的数据3、PUT方法跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有4、HEAD方法只请求页面的首部5、DELETE方法删除服务器上的某资源6、OPTIONS方法它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息7、TRACE方法TRACE方法被用于激发一个远程的，应用层的请求消息回路8、CONNECT方法把请求连接转换到透明的TCP/IP通道 4、从浏览器地址栏输入url到显示页面的步骤1234浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。 5、如何进行网站性能优化123456789101112131415161718192021222324252627282930content方面减少HTTP请求：合并文件、CSS精灵、inline Image减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名减少DOM元素数量Server方面使用CDN配置ETag对组件使用Gzip压缩Cookie方面减小cookie大小css方面将样式表放到页面顶部不使用CSS表达式使用&lt;link&gt;不使用@importJavascript方面将脚本放到页面底部将javascript和css从外部引入压缩javascript和css删除不需要的脚本减少DOM访问图片方面优化图片：根据实际颜色需要选择色深、压缩优化css精灵不要在HTML中拉伸图片 6、HTTP状态码及其含义123456789101112131415161718191XX：信息状态码100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息2XX：成功状态码200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理3XX：重定向301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。4XX：客户端错误400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。5XX: 服务器错误500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 7、语义化的理解12345用正确的标签做正确的事情！html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8、介绍一下你对浏览器内核的理解？123456主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核JS引擎则：解析和执行javascript来实现网页的动态效果最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 9、html5有哪些新特性、移除了那些元素？12345678910111213141516171819HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加绘画 canvas用于媒介回放的 video 和 audio 元素本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失sessionStorage 的数据在浏览器关闭后自动删除语意化更好的内容元素，比如article、footer、header、nav、section表单控件，calendar、date、time、email、url、search新的技术webworker, websocket, Geolocation移除的元素：纯表现的元素：basefont，big，center，font, s，strike，tt，u`对可用性产生负面影响的元素：frame，frameset，noframes支持HTML5新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签可以利用这一特性让这些浏览器支持HTML5新标签浏览器支持新标签后，还需要添加标签默认的样式当然也可以直接使用成熟的框架、比如html5shim 10、HTML5的离线储存怎么使用，工作原理能不能解释一下？123456789在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示如何使用：页面头部像下面一样加入一个manifest的属性；在cache.manifest文件的编写离线存储的资源在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢123在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 12、请描述一下 cookies，sessionStorage 和 localStorage 的区别？123456789101112cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存存储大小：cookie数据大小不能超过4ksessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大有期时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据sessionStorage 数据在当前浏览器窗口关闭后自动删除cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13.iframe有那些缺点？1234iframe会阻塞主页面的Onload事件搜索引擎的检索程序无法解读这种页面，不利于SEOiframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 14.WEB标准以及W3C标准是什么?1标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 15、xhtml和html有什么区别?1234一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?123456页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是XHTML标签，无兼容问题link方式的样式的权重 高于@import的权重&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？12345行内元素有：a b span img input select strong块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;行内元素不可以设置宽高，不独占一行块级元素可以设置宽高，独占一行 18、HTML全局属性(global attribute)有哪些1234567class:为元素设置类标识data-*: 为元素增加自定义属性draggable: 设置元素是否可拖拽id: 元素id，文档内唯一lang: 元素内容的的语言style: 行内css样式title: 元素相关的建议信息 19、Canvas和SVG有什么区别？12svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？12HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 21、如何在页面上实现一个圆形的可点击区域？123svgborder-radius纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 22、网页验证码是干嘛的，是为了解决什么安全问题123区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试$CSS部分 1、css sprite是什么,有什么优缺点1234567891011概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。优点：减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：图片合并麻烦维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2、display: none;与visibility: hidden;的区别123456联系：它们都能让元素不可见区别：display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3、link与@import的区别123456link是HTML方式， @import是CSS方式link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUClink可以通过rel=&quot;alternate stylesheet&quot;指定候选样式浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式@import必须在样式规则之前，可以在css文件中引用其他文件总体来说：link优于@import 4、什么是FOUC?如何避免12Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head 5、如何创建块级格式化上下文(block formatting context),BFC有什么用1234567891011创建规则：根元素浮动元素（float不是none）绝对定位元素（position取值为absolute或fixed）display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素overflow不是visible的元素作用：可以包含浮动元素不被浮动元素覆盖阻止父子元素的margin折叠 6、display,float,position的关系123456如果display为none，那么position和float都不起作用，这种情况下元素不产生框否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。否则，如果float不是none，框是浮动的，display根据下表进行调整否则，如果元素是根元素，display根据下表进行调整其他情况下display的值为指定值总结起来：绝对定位、浮动、根元素都需要调整display 7、清除浮动的几种方式，各自的优缺点1234567父级div定义height结尾处加空div标签clear:both父级div定义伪类:after和zoom父级div定义overflow:hidden父级div也浮动，需要定义宽度结尾处加br标签clear:both比较好的是第3种方式，好多网站都这么用 8、为什么要初始化CSS样式?12因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 9、css3有哪些新特性12345678910111213141516171819新增各种css选择器圆角 border-radius多列布局阴影和反射文字特效text-shadow线性渐变旋转transformCSS3新增伪类有那些？p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个&lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:after 在元素之前添加内容,也可以用来做清除浮动。:before 在元素之后添加内容:enabled:disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中 10、display有哪些值？说明他们的作用123456block 象块类型元素一样显示。none 缺省值。象行内元素类型一样显示。inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。list-item 象块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示inherit 规定应该从父元素继承 display 属性的值 11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？123有两种， IE盒子模型、W3C盒子模型；盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；区 别： IE的content部分把 border 和 padding计算了进去; 12、CSS优先级算法如何计算？123优先级就近原则，同权重情况下样式定义最近者为准载入样式以最后载入的定位为准优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 13、对BFC规范的理解？1它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用 14、谈谈浮动和清除浮动1浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 15、position的值， relative和absolute定位原点是12345absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位fixed：生成绝对定位的元素，相对于浏览器窗口进行定位relative：生成相对定位的元素，相对于其正常位置进行定位static 默认值。没有定位，元素出现在正常的流中inherit 规定从父元素继承 position 属性的值 16、display:inline-block 什么时候不会显示间隙？(携程)12345移除空格使用margin负值使用font-size:0letter-spacingword-spacing 17、PNG,GIF,JPG的区别及如何选12345678910111213141516GIF8位像素，256色无损压缩支持简单动画支持boolean透明适合简单动画JPEG颜色限于256有损压缩可控制压缩质量不支持透明适合照片PNG有PNG8和truecolor PNGPNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画适合图标、背景、按钮 18、行内元素float:left后是否变为块级元素？1浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置display:block;。但如果元素设置了浮动后再设置display:block;那就不会占一行。 19、在网页中的应该使用奇数还是偶数的字体？为什么呢？1偶数字号相对更容易和 web 设计的其他部分构成比例关系 20、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用12单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素用于区分伪类和伪元素 21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 22、CSS合并方法1避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 23、CSS不同选择器的权重(CSS层叠的规则)123456！important规则最重要，大于其它规则行内样式规则，加1000对于选择器中给定的各个ID属性值，加100对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10对于选择其中给定的各个元素标签选择器，加1如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 24、列出你所知道可以改变页面布局的属性1position、display、float、width、height、margin、padding、top、left、right、 25、CSS在性能优化方面的实践123css压缩与合并、Gzip压缩css文件放在head里、不要用@import尽量用缩写、避免用滤镜、合理使用选择器 26、CSS3动画（简单动画的实现，如旋转等）1234依靠CSS3中提出的三个属性：transition、transform、animationtransition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。transform：定义元素的变化结果，包含rotate、scale、skew、translate。animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction 27、base64的原理及优缺点12优点可以加密，减少了http请求缺点是需要消耗CPU进行编解码 $JavaScript1、闭包123456789101112131415161718192021222324闭包就是能够读取其他函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域闭包的特性：函数内再嵌套函数内部函数可以引用外层的参数和变量参数和变量不会被垃圾回收机制回收说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中闭包的另一个用处，是封装对象的私有属性和私有方法好处：能够实现封装和缓存等；坏处：就是消耗内存、不正当使用会造成内存溢出的问题使用闭包的注意点由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露解决方法是，在退出函数之前，将不使用的局部变量全部删除 2、说说你对作用域链的理解12作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3、JavaScript原型，原型链 ? 有什么特点？123456每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念关系：instance.constructor.prototype = instance.__proto__特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 4、请解释什么是事件代理123事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒可以实现当新增子对象时无需再次对其绑定 5、Javascript如何实现继承？12345构造继承原型继承实例继承拷贝继承原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 1234567891011function Parent()&#123; this.name = &apos;wang&apos;; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; 6、谈谈This对象的理解123this总是指向函数的直接调用者（而非间接调用者）如果有new关键字，this指向new出来的那个对象在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 7、事件模型1W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 12345冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件阻止冒泡：在W3c中，使用stopPropagation（）方法；在IE下设置cancelBubble = true阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault（）方法，在IE下设置window.event.returnValue = false 8、new操作符具体干了什么呢?123创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型属性和方法被加入到 this 引用的对象中新创建的对象由 this 所引用，并且最后隐式的返回 this 9、Ajax原理12Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 1234567891011121314151617// 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open(&apos;get&apos;, url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; // fail fail &amp;&amp; fail(xhr.status); &#125; &#125; &#125; ajax 有那些优缺点? 123456789优点：通过异步模式，提升了用户体验.优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。Ajax可以实现动态不刷新（局部刷新）缺点：安全问题 AJAX暴露了与服务器交互的细节。对搜索引擎的支持比较弱。不容易调试。 10、如何解决跨域问题?1jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 11、模块化开发怎么做？立即执行函数,不暴露私有成员12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 12、异步加载JS的方式有哪些？123defer，只支持IEasync：创建script，插入到DOM中，加载完毕后callBack 13、那些操作会造成内存泄漏？123内存泄漏指任何对象在您不再拥有或需要它之后仍然存在setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏闭包使用不当 14、XML和JSON的区别？123456789101112数据体积方面JSON相对于XML来讲，数据的体积小，传递的速度更快些。数据交互方面JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互数据描述方面JSON对数据的描述性比XML较差传输速度方面JSON的速度要远远快于XML 15、谈谈你对webpack的看法1WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 16、说说你对AMD和Commonjs的理解12CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17、常见web安全及防护原理1234567891011121314151617181920212223242526sql注入原理就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令总的来说有以下几点永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息XSS原理及防范Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点XSS防范方法首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤登录受信任网站A，并在本地生成Cookie在不登出A的情况下，访问危险网站BCSRF的防御服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数通过验证码的方法 18、用过哪些设计模式？12345678工厂模式：工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字构造函数模式使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于直接将属性和方法赋值给 this对象; 19、为什么要有同源限制？12同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别123offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 21、javascript有哪些方法定义对象123对象字面量： var obj = &#123;&#125;;构造函数： var obj = new Object();Object.create(): var obj = Object.create(Object.prototype); 22、常见兼容性问题？12png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一,，但是全局效率很低，一般是如下这样解决： 1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125; IE下,event对象有x,y属性,但是没有pageX,pageY属性Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 22、说说你对promise的了解1234567891011121314依照 Promise/A+ 的定义，Promise 有四种状态：pending: 初始状态, 非 fulfilled 或 rejected.fulfilled: 成功的操作.rejected: 失败的操作.settled: Promise已被fulfilled或rejected，且不是pending另外， fulfilled与 rejected一起合称 settledPromise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算Promise 的构造函数 构造一个 Promise，最基本的用法如下：1234567var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：1promise.then(onFulfilled, onRejected) 1接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject 23、你觉得jQuery源码有哪些写的好的地方1234jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 24、vue、react、angular12345678Vue.js一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 FiltersAngularJS是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令reactReact 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 25、Node的应用场景1234567891011121314特点：1、它是一个Javascript运行环境2、依赖于Chrome V8引擎进行代码解释3、事件驱动4、非阻塞I/O5、单进程，单线程优点：高并发（最重要的优点）缺点：1、只支持单核CPU，不能充分利用CPU2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 26、谈谈你对AMD、CMD的理解123CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 27、那些操作会造成内存泄漏？123内存泄漏指任何对象在您不再拥有或需要它之后仍然存在setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 28、web开发中会话跟踪的方法有哪些12345cookiesessionurl重写隐藏inputip地址 29、介绍js的基本数据类型1Undefined、Null、Boolean、Number、String 30、介绍js有哪些内置对象？123Object 是 JavaScript 中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 31、说几条写JavaScript的基本规范？1234567不要在同一行声明多个变量请使用===/!==来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数Switch语句必须带有default分支If语句必须使用大括号for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？123456栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（对象、数组和函数）两种类型的区别是：存储位置不同；原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 33、javascript创建对象的几种方式？1javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式1person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;; 用function来模拟无参的构造函数12345678function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function()&#123; alert(person.name+&quot; hello...&quot;); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125; &#125; var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象）1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 用原型方式来创建12345678function Dog()&#123; &#125; Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;); &#125; var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125; var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); 34、eval是做什么的？123它的功能是把对应的字符串解析成JS代码并运行应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&apos;(&apos;+ str +&apos;)&apos;) 35、null，undefined 的区别？12345678910undefined 表示不存在这个值。undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined例如变量被声明了，但没有赋值时，就等于undefinednull 表示一个对象被定义了，值为“空值”null : 是一个对象(空对象, 没有任何属性和方法)例如作为函数的参数，表示该函数的参数不是对象；在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 36、[“1”, “2”, “3”].map(parseInt) 答案是多少？12[1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。 37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？1use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 38、JSON 的了解？**JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象:123var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); 39、js延迟加载的方式有哪些？1defer和async、动态创建DOM方式（用得最多）、按需异步载入js 40、同步和异步的区别?12同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 41、渐进增强和优雅降级123渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 42、defer和async12defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 43、说说严格模式的限制1234变量必须声明后再使用函数的参数不能有同名属性，否则报错不能使用with语句禁止this指向全局对象 44、attribute和property的区别是什么？1234attribute是dom元素在文档中作为html标签拥有的属性；property就是dom元素在js中作为对象拥有的属性。对于html的标准属性来说，attribute和property是同步的，是会自动更新的但是对于自定义的属性来说，他们是不同步的 45、谈谈你对ES6的理解123456789新增模板字符串（为JavaScript提供了简单的字符串插值功能）箭头函数for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。还有就是引入module模块的概念 46、ECMAScript6 怎么写class么，为什么会出现class这种东西?12这个语法糖可以让有OOP基础的人更快上手js，至少是一个官方的实现了但对熟悉js的人来说，这个东西没啥大影响；一个Object.creat()搞定继承，比class简洁清晰的多 47、什么是面向对象编程及面向过程编程，它们的异同和优缺点123面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为面向对象是以功能来划分问题，而不是步骤 48、面向对象编程思想1234567基本思想是使用对象，类，继承，封装等基本概念来进行程序设计优点易维护采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的易扩展开发工作的重用性、继承性高，降低重复工作量。缩短了开发周期 49、对web标准、可用性、可访问性的理解123可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 $编程题1、写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125; 2、如何判断一个对象是否为数组123456function isArray(arg) &#123; if (typeof arg === &apos;object&apos;) &#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; &#125; return false;&#125; 3、冒泡排序每次比较相邻的两个数，如果后一个比前一个小，换位置123456789101112131415var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) &#123;for (var i = 0; i &lt; arr.length - 1; i++) &#123; for(var j = 0; j &lt; arr.length - 1; j++) &#123; if(arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;return arr;&#125;console.log(bubbleSort(arr)); 4、快速排序采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边12345678910111213141516171819var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125;console.log(quickSort(arr)); 5、编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节123456789function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(&quot;你好,as&quot;)); 6、bind的用法，以及如何实现bind的函数和需要注意的点1bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。 一个简单的bind函数实现如下123456Function.prototype.bind = function(ctx) &#123; var fn = this; return function() &#123; fn.apply(ctx, arguments); &#125;;&#125;; $其他1、谈谈你对重构的理解12345678910网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI对于传统的网站来说重构通常是：表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化 2、什么样的前端代码是好的1高复用低耦合，这样文件小，好维护，而且好扩展。 3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？12345678910前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近实现界面交互提升用户体验有了Node.js，前端可以实现服务端的一些事情前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，与团队成员，UI设计，产品经理的沟通；做好的页面结构，页面重构和用户体验； 4、你觉得前端工程的价值体现在哪123456789为简化用户使用提供技术支持（交互部分）为多个浏览器兼容性提供支持为提高用户浏览速度（浏览器性能）提供支持为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持为展示数据提供支持（数据接口） 5、平时如何管理你的项目？12345678910111213先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；页面进行标注（例如 页面 模块 开始和结束）；CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；JS 分文件夹存放 命名以该JS功能为准的英文翻译。图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理","tags":[]},{"title":"ES6的promise","date":"2017-03-28T08:43:53.899Z","path":"2017/03/28/ES6中promise/","text":"什么是PromisePromise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ES6中的Promise先在控制台打印出Promise看看，console.dir(Promise);显示如下; 由上图可知，Promise是一个函数，自己身上有all、race、reject、resolve等方法，原型上有then、catch等方法 ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected 创造了一个Promise实例： 123456789101112var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); var num = Math.random(); if(num&gt;=0.5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字小于0.5&apos;); &#125; &#125;, 2000);&#125;); 上面的代码中，设置了一个2s后执行的定时器。 2s以后输出“执行完成”，然后生成一个随机数，如果数字大于等于0.5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为“失败”的原因。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“已解决”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“拒绝”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise示例123456789101112function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&apos;Could not load image at &apos; + url)); &#125;; image.src = url; &#125;);&#125; 使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。 1234567891011121314151617181920212223242526function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 2000); &#125;); return p;&#125;getNumber().then( function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); &#125;, function(reason, data)&#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： resolved 1（数字随机，只是个举例） 或者是 rejected 数字太小了（ Promise.prototype.then()then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 从表面上看，Promise只是简化了层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。 12345678910111213141516171819202122232425262728293031323334353637383940function runAsync1()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成1&apos;); resolve(&apos;数据1&apos;); &#125;, 2000); &#125;);&#125;function runAsync2()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成2&apos;); resolve(&apos;数据2&apos;); &#125;, 2000); &#125;);&#125;function runAsync3()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成3&apos;); resolve(&apos;数据3&apos;); &#125;, 2000); &#125;);&#125;//调用runAsync1().then(function(data)&#123; console.log(data); return runAsync2(); //return的是一个promise对象&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); 1234567代码执行的结果执行完成1数据1执行完成2数据2执行完成3数据3 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 12345new Promise(function(resolve, reject) &#123; throw new Error(&apos;test&apos;);&#125;).catch(function(error) &#123; console.log(error); &#125;); 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。需要注意的是，catch方法返回的还是一个 Promise对象，因此后面还可以接着调用then方法。 123456789101112131415var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log(&apos;oh no&apos;, error);&#125;).then(function() &#123; console.log(&apos;carry on&apos;);&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 下面是一个例子，其中 runAsync1、 runAsync1 和runAsync3上面的例子中已有定义 Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 上述结果为: 1234执行完成1执行完成2执行完成3[&quot;数据1&quot;,&quot; 数据2&quot;,&quot;数据3&quot;] 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 all方法的效果实际上是「谁跑的慢，以谁为准执行回调」(以执行最慢的那个为准的话这个时候所有的数据都可以获取到的，以数组的形式展现)，那么相对的就有另一个方法race「谁跑的快，以谁为准执行回调」。 我们把上面runAsync1的延时改为1秒来看一下： 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 1234执行完成1数据1执行完成2执行完成3 在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： 12345678910111213141516171819202122232425262728//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = &apos;xxxxxx&apos;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。","tags":[]},{"title":"ES6新特性","date":"2017-03-28T08:41:25.910Z","path":"2017/03/28/ES6新特性/","text":"一、作用域 块级作用域 块级变量let 块级常量 const 二、箭头函数 sum = (a,b)=&gt; a + b nums.forEach(v=&gt; {console.log(v)}) 词法 this 三、参数处理 默认参数值 剩余参数 展开运算符 四、模板字面量 多行字符串 字符串插值 带标签的模板字面量 原始字符串 五、原有字面量加强 更安全的二进制字面量(0b1111101) 更安全的八进制字面量(0o767) 字符串支持Unicode String.fromCodePoint String.prototype.codePointAt 正则表达式字面量添加 Unicode 正则表达式添加y标记，支持粘滞匹配 对象属性加强 属性定义支持短语法obj = {x,y} 属性名支持表达式 obj = {[“baz”+quux()]:42} 添加proto属性，但不建议使用 六、解构赋值 匹配 [b,a] = [a,b] 对象匹配 let {a,b,c} = objABC 参数匹配 function g({name:n,val:v}){} 七、模块 导入(import) 导出(export) 默认导出(export default) 八、类 使用extends继承 重写构造器 super关键字 九、迭代 迭代器 for of 十、生成器 十一、promise点击了解promise. 十二、元编程 代理(proxy) 反射(Reflex) 十三、新增数据类型 Symbol类型 Set类型 Map类型 WeakSet类型 WeakMap类型 TypedArray类型 十四、原有内置对象API增强 Object.assign Array.from Array.of Array.prototype.fill Array.prototype.find Array.prototype.findIndex Array.prototype.copyWithin Array.prototype.entries Array.prototype.keys Array.prototype.values String.prototype.includes String.prototype.repeat String.prototype.startsWidth String.prototype.endsWidth() Number.EPSILON Number.isInteger Number.isSafeInteger Number.isFinite Number.isNaN(“NaN”) Math.acosh Math.hypot Math.imul Math.sign Math.trunc","tags":[]},{"title":"markdown使用","date":"2017-03-28T07:29:02.205Z","path":"2017/03/28/markdown使用/","text":"插入图片 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 Markdown 语法:123456789101112131415A First Level Header====================A Second Level Header---------------------Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.The quick brown fox jumped over the lazydog&apos;s back.### Header 3&gt; This is a blockquote.&gt;&gt; This is the second paragraph in the blockquote.&gt;&gt; ## This is an H2 in a blockquote 输出 HTML 为：12345678910111213&lt;h1&gt;A First Level Header&lt;/h1&gt;&lt;h2&gt;A Second Level Header&lt;/h2&gt;&lt;p&gt;Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.&lt;/p&gt;&lt;p&gt;The quick brown fox jumped over the lazydog&apos;s back.&lt;/p&gt;&lt;h3&gt;Header 3&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;This is a blockquote.&lt;/p&gt;&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;&lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法:1234Some of these words *are emphasized*.Some of these words _are emphasized also_.Use two asterisks for **strong emphasis**.Or, if you prefer, __use two underscores instead__. 输出 HTML 为:1234&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：123* Candy.* Gum.* Booze. 加号：123+ Candy.+ Gum.+ Booze. 和减号123- Candy.- Gum.- Booze. 都会输出 HTML 为：12345&lt;ul&gt;&lt;li&gt;Candy.&lt;/li&gt;&lt;li&gt;Gum.&lt;/li&gt;&lt;li&gt;Booze.&lt;/li&gt;&lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记：1231. Red2. Green3. Blue 输出 HTML 为：12345&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。123* A list item.With multiple paragraphs.* Another item in the list. 输出 HTML 为：12345&lt;ul&gt;&lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt;&lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接：1This is an [example link](http://example.com/). 输出 HTML 为：12&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性：1This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为：12&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：12345I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为：1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot;title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot;title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：123I start my morning with a cup of coffee and[The New York Times][NY Times].[ny times]: http://www.nytimes.com/ 输出 HTML 为：12&lt;p&gt;I start my morning with a cup of coffee and&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）：1![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式：12![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为：1&lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：123I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `&amp;mdash;`instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为：12345&lt;p&gt;I strongly recommend against using any&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;&lt;p&gt;I wish SmartyPants used named entities like&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encodedentites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法:12If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes: For example. 输出 HTML 为：123456&lt;p&gt;If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/code&gt;&lt;/pre&gt; 1转载：http://www.appinn.com/markdown/","tags":[]},{"title":"MVC、MVP、MVVM之间的关系","date":"2017-03-28T07:26:09.493Z","path":"2017/03/28/MVC和MVP及MVVM之间的关系/","text":"一、MVC什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 二、MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 三、MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然","tags":[]},{"title":"css实现九宫格（兼容问题）","date":"2017-03-28T07:26:09.422Z","path":"2017/03/28/九宫格/","text":"前段时间，我的 leader Henry在群里面分享了一道一淘的面试题。 题目非常的有趣，忙完前阵的工作之后突然记起，也尝试做了一下。 129个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 做成九宫格大家都会，但题目的陷阱就在hover上。鼠标hover到格子4，格子5时，其实他们“共用”了一条边。由于是纯css实现的，我们不可能说用js去动态改变dom，因此怎样实现“公用边”就成为了难点。 尝试的过程： 我的第一个想法，用“叠加”的方式实现“公用边”； 后来的想法，用table的border-collapse实现“公用边”； 在table想法的基础上改进； 一种更简便的做法，不需要border，见九宫格(二)我的第一个想法先做做看，尝试永远是第一步。我将9个div都设置了5px的border，排成了九宫格，添加了hover，这时候初始的效果是：这样其实格子之间的距离是两倍border（10px）。需要再将中间的一竖（2，5，8）设置margin-left:-5px;margin-right:-5px;,再将中间的一横（3，4，5）设置margin-top:-5px;margin-bottom:-5px;，这样等于是强制把格子间的距离“拉”到5px。到这一步，简单的九宫格是完成了，但hover之后会发现，格子的边会被挡住（格子5的下边和右边分别被格子8和格子6挡住）。因为这里“公用边”的思路准确来说是“重合边”，是用负值的margin强制定位的。而我的解决方式是hover时添加z-index:999，让hover到的格子在最上层显示而不会被挡住。同时，不要忘记在9个div的css里面添加一句让z-index生效的position: relative;，具体原因看这里。代码君：1.html：1234567891011&lt;div id=&quot;test0&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;lr_indent tb_indent&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 2.css:1234567891011121314151617181920212223242526272829#test0&#123; margin: 30px; width: 200px; height: 200px;&#125;#test0 div&#123; width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative;&#125;#test0 .lr_indent&#123; margin-left: -5px; margin-right: -5px;&#125;#test0 .tb_indent&#123; margin-top: -5px; margin-bottom: -5px;&#125;#test0 div:hover&#123; border: 5px solid #f00; z-index: 999; background: #eee;/*必须加这一句，在IE6，7有bug*/&#125; 思考：这样的方式好吗？不够好。这才是9宫格，如果是16，25，…，81个格子，设置margin缩进的人力代价是很高的。兼容性，在IE6，7下，负值margin在hover时候有bug。 后来的想法经过第一次尝试，我得到一个经验：要用一种通用的方法去解决“公用边”，而不是分别设置.lr_indent和.tb_indent。随即我想到了表格。作为table，它有个很突出的属性，就是合并border，css里面的设置为border-collapse:collapse;。ok，这就是key point。 按照这个思路，我简单的编写了代码，一开始我把hover定位到td上面去，发现hover时也会出现第一个想法中“挡住”的情况。而且，去将td的position改变，再添加z-index的方法是不可能有用的(z-index不会起效)。 我的方法是在td中包含一个span，把hover定位到span中去，td设置为position:relative;，span设置为position:absolute;，这时候的hover就可以设置让span的border不被挡住展示了。代码君又来了：html：12345678910111213141516171819&lt;div id=&quot;test1&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;9&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css：123456789101112131415161718192021222324252627282930*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test1 td&#123; width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center;&#125;#test1 td span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test1 td span:hover&#123; border: 5px solid #f00; margin-top:-5px; margin-left: -5px;&#125; 别忘了span在hover时，必须设置一个负的margein-top和margein-left，以保证红色边框恰好定位在格子四周。见css君最后的片段。假如不设置，你看到的将是这样：本以为已经大功告成了，在IE中测试却让我傻了眼：（ps：作为前端一枚，我已经做好了妥妥的心理准备，但此情此景还是让人喷出一口老血……） 改进，改进说实话，table和div之争这么多年，大家都在页面中用越来越多的div，而越发的鄙视table，反而对table的熟悉程度反应了前端们的基础是否扎实。吃一堑长一智，这句话特别适用于在table中翻江倒海的亲们。 改进！ 首先这个bug（也无所谓是不是bug，算是浏览器的差异性吧）我知道，在table的td里面设置了position:relative;就会在IE中出现这样的情况。注意是所有的IE哦，包括IE10。而根据第二个思路，最后的hover定位的元素为span，它本身设定为position:absolute;它的父级元素必须得设置position:relative;才能完成题目功能，这是毋庸置疑的。 既然现在span的父级td不能设置position:relative;，我就在它们之间添加一个div，用来做span的容器。 代码君再一次来了：html:12345678910111213141516171819&lt;div id=&quot;test2&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;4&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;6&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;7&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;8&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;9&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css:1234567891011121314151617181920212223242526272829303132333435*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test2 td&#123; width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top;&#125;#test2 td div&#123; position:relative; width: 50px; height: 50px;&#125;#test2 td div span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test2 td div span:hover&#123; border: 5px solid #f00; margin-left: -5px; margin-top: -5px;&#125; OK，效果达成！最终完成的效果 最后吐槽，不对，总结一下下：先到IE上去测，再转到其它浏览器，以少走弯路，这叫擒贼先擒王-_-!；win8的metro布局最近挺流行的，有时候table比div好用；IE君，你真是……此处省略1024个字","tags":[]},{"title":"路由","date":"2017-03-21T04:54:58.000Z","path":"2017/03/21/路由/","text":"为什么路由的路径后面加上 “#!/” #是哈希值，默认是不会被浏览器搜索到的，加上！号就可以被搜索到了","tags":[]},{"title":"ES6","date":"2017-03-19T12:55:15.852Z","path":"2017/03/19/ES6/","text":"环境搭建 创建.gitignore 和 readme.md文件：touch .gitignore README.md 初始化package.json文件 npm install babel-cli babel-preset-es2015 –save-dev 在package.json的scripts中配置：”dev”:”babel src -d dist -w” 创建.babelrc文件：touch .babelrc; 在里面配置：123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; 基本项目目录结构的说明1234src es6源代码dist es6-&gt;es5可运行代码index.html 加载dist目录下的代码，测试package.json 如何开发1npm run dev 箭头函数 箭头函数 使用=&gt;对函数定义的简写。支持两种写法：表达式和函数体 表达式 1234let fn3=p=&gt;p中间的p代表参数，箭头后面的p，代表返回值；let fn3=()=&gt;&apos;无参数输入的箭头函数&apos;let fn3=(a,b)=&gt;a+b; 同上; 函数体(显式写法) 1234let fn3=(a,b)=&gt;&#123; var m=a+b; return m;&#125; 注意：箭头函数体中this : 共用父级作用域的关键字this； 定义一个类及类的继承 创建类，添加公有方法和静态方法； 123456789101112class Father&#123; //用class创建一个类 construcotr(name,age)&#123;//用constructor创建构造函数 this.name=name; this.age=age; &#125; getMessage()&#123;//添加公有方法 console.log(this.name+&apos;的年龄是&apos;+this.age+&apos;岁了&apos;) &#125; static like()&#123; //静态方法 console.log(&apos;我是静态方法&apos;) &#125;&#125; 构造函数的继承 123456789class Sun extends Father&#123;//子类继承父类 constructor(name,age,color)&#123; super(name,age);//必须写； this.color=color; &#125; getColor()&#123; console.log(this.name+&apos;喜欢的颜色是：&apos;+this.color); &#125;&#125; 增强的对象字面量优点：1）写法简化 2）原型继承–类似于“类”；12345var obj=&#123;data:123&#125;;var a=1;var b=&apos;2&apos;;var fn=(n,m)=&gt;console.log(n+m);var objOther=&#123;__proto__:obj,a,b,fn&#125; 模板字符串123var name=&apos;tangtang&apos;;var age=2;var str=`$&#123;name&#125;已经$&#123;age&#125;岁了`； 注意：用的是``(键盘左上角1旁边的)而不是普通的单引号‘’; 解构赋值123var obj=&#123;a:1,b:&apos;2&apos;,fn()&#123;console.log(&apos;我是函数&apos;)&#125;&#125;;var &#123;a,b,fn&#125;=obj;//这样就能拿到a,b,fn任何一个属性的值；var &#123;Alert,ListView,Text&#125;=reuqire(&apos;reactNative&apos;);//同上； 默认参数，任意参数，扩展运算符 默认参数-减少代码逻辑：function(a=’tangtang’,b=123){} 任意参数-不依赖arguments解决常见问：function(a,…keys) 扩展运算符:123var ary=[1,23,21];var newAry=[...ary,1000,10000];Math.max(...ary); let和const 新增块级作用域，用let； const是常量，不能重复赋值； 都没有预解释；","tags":[]},{"title":"html包含另外html页面的方法","date":"2017-03-19T04:06:36.785Z","path":"2017/03/19/html包含另外html页面的方法/","text":"一、用object对象1&lt;object style=&quot;border:0px&quot; type=&quot;text/x-scriptlet&quot; data=&quot;111.html&quot; width=100% height=500&gt;&lt;/object&gt;（这个在ie下面不正常） 二、用iframe1&lt;iframe src=&quot;111.html&quot; style=&quot;width:680px; height:auto;&quot;&gt;","tags":[]},{"title":"MongoDB","date":"2017-02-17T11:08:58.000Z","path":"2017/02/17/mongoDB/","text":"安装MongoDB安装1264mongod --dbpath=./data 1232位mongod --dbpath=./data --storageEngine=mmapv1(搜索引擎) mongoose导入mongoose模块1var mongoose = require(&apos;mongoose&apos;); 服务器的实例和服务器分别是谁？？？？连接数据库connect，201613node为数据库名1mongoose.connect(&apos;mongodb://localhost/201613node&apos;); 集合的骨架模型:规定了集合中文档的字段名和字段的类型123456var PersonSchema = new mongoose.Schema(&#123; name:String, //人的姓名 age:Number, //人的年龄 home:String&#125;);//此骨架模型指定存的时候只能是name和age不能是别的，而且类型也是指定的类型 外键1234567 * 节省空间 第一定义多次使用 * 方便修改 一次修改多处修改&#123; cardid:417, //主键 name:&apos;杨过&apos;， cardfk:418 //外键&#125; 根据schema定义操作数据库的对象模型(集合名称=模型名-&gt;转小写-&gt;转复数)Person-&gt;person-&gt;people1var Person = mongoose.model(&apos;Person&apos;,PersonSchema); Person.create创建文档并插入数据库123Person.create(&#123;id:5,name:&apos;zfpx5&apos;,age:50,home:&quot;北京&quot;&#125;,function(err,result)&#123; console.log(err);&#125;); 121.如果传入的类型多于schema的定义，那么多余的字段会忽略掉2.如果传入的值和schema规定的类型不匹配，那么mongoose会尝试进行数据类型转换，如果转换成功，则成功保存，如果转换失败，则保存失败 Person.find查询：返回永远是数组格式，没有东西返回则也返回个空数组，12345* 参数1 是查询的条件，当第一个参数为&#123;&#125;，表示查询所有* 参数2 规定想要查询出来的字段的名称* &#123;age:1&#125; 表示只查询这些字段，其它字段均忽略掉不返回* &#123;age:0&#125; 表示只排除掉这些字段，其它字段均返回* 参数3 回调函数 1234Person.find(&#123;&#125;,&#123;age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;); Person.update跟新默认是更新一条123456789Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function(err,result)&#123; console.log(result); &#125;);Person.update(&#123;age:&#123;$lt:50&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function (err, result) &#123; console.log(result);&#125;);Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function (err, result) &#123; console.log(result);&#125;); 1234&#123; ok: 1, nModified: 1, n: 1 &#125;&#123; ok: 1, nModified: 0, n: 1 &#125;&#123; ok: 1, nModified: 1, n: 2 &#125;ok=1:是成功了;nModified:修改的条数;n:匹配到的条数 1234561 参数是更新的条件,更新的范围 * $in 表示在一个数组范围内 &#123;age:&#123;$in:[50,100]&#125;&#125; * $gt 大于 $gte大于等于 $lt小于 $lte 小于等于2 参数是更新后的值对象3 更新选项 &#123;multi:true&#125;默认是更新一条，加上他为更新所有******************4 回调函数(错误对象,更新结果) Person.remove删除的时候默认会删除掉全部匹配的数据,更新默认是更新一条1234Person.remove(&#123;name:&apos;zfpx2&apos;&#125;,function(err,result)&#123; console.log(err); console.log(result.result);&#125;) 根据ID查询文档1234Person.findById(&quot;58b101946d87bf0d34abaa7a&quot;,function(err,doc)&#123; console.log(err); console.log(doc);&#125;); Person.findOne查询,最多找一条记录,如果匹配一条满足条件的则停止继续查找123Person.findOne(&#123;&#125;,function(err,docs)&#123; console.log(docs); &#125;); mongoose.Promise=Promise;如果不加的话会有警示，mongoose.Promise为被废弃的，需要改为Promise**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//导入mongoose模块var mongoose = require(&apos;mongoose&apos;);//连接数据库mongoose.connect(&apos;mongodb://localhost/201613node&apos;);/** * 集合的骨架模型 * 规定了集合中文档的字段名和字段的类型 */var PersonSchema = new mongoose.Schema(&#123; name:String, //人的姓名 age:Number, //人的年龄 home:String&#125;);//根据schema定义操作数据库的对象模型//集合名称=模型名-&gt;转小写-&gt;转复数// Person-&gt;person-&gt;peoplevar Person = mongoose.model(&apos;Person&apos;,PersonSchema);/** * 如果传入的类型多于schema的定义，那么多余的字段会忽略掉 * 如果传入的值和schema规定的类型不匹配，那么mongoose会尝试进行数据类型转换，如果转换成功，则成功保存，如果转换失败，则保存失败 *//*Person.create(&#123;id:5,name:&apos;zfpx5&apos;,age:50,home:&quot;北京&quot;&#125;,function(err,result)&#123; console.log(err);&#125;);*//** * 查询 * 1参数是查询的条件 * 2参数 规定查询出来的字段的名称 * :1 表示只查询这些字段，其它字段均忽略掉不返回 * :0 表示只排除掉这些字段，其它字段均返回 *///BadValue Projection// cannot have a mix of inclusion and exclusion.// 除了男生都站起来 只让女生站起来/*Person.find(&#123;&#125;,&#123;age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;);*/// &#123; ok: 1, nModified: 1, n: 1 &#125;// &#123; ok: 1, nModified: 0, n: 1 &#125;//&#123; ok: 1, nModified: 1, n: 2 &#125;// ok=1 是成功了 nModified 修改的条数 n是查找匹配到的条数/** * 1 参数是更新的条件 更新的范围 * 2 参数是更新后的值对象 * 3 更新选项 &#123;multi:true&#125;什么意思？ * 4 回调函数，错误对象 更新结果 * $in 表示在一个数组范围内 * $gt 大于 $gte大于等于 $lt小于 $lte 小于等于 */// Person.update(&#123;age:&#123;$in:[50,100]&#125;&#125;,&#123;home:&apos;上海&apos;&#125;,&#123;multi:true&#125;,function(err,result)&#123;// console.log(result);// &#125;);//删除的时候默认会删除掉全部匹配的数据/*Person.remove(&#123;name:&apos;zfpx2&apos;&#125;,function(err,result)&#123; console.log(err); console.log(result.result);&#125;)*///根据ID查询文档Person.findById(&quot;58b101946d87bf0d34abaa7a&quot;,function(err,doc)&#123; console.log(err); console.log(doc);&#125;);//查询找最多一条记录 如果匹配一条满足条件的则停止继续查找Person.findOne(&#123;&#125;,function(err,docs)&#123; console.log(docs);&#125;); .skip()跳过指定的条数.limit()限定返回的条数.sort({age:1}) 排序，按哪个字段排序，正序1还是倒序-1.exec(function(err,docs){}) 执行1当skip sort limit的时候并没有真正执行查询,当调用exec的时候才真正执行查询 123456789101112131415161718192021222324252627282930313233343536var mongoose = require(&apos;mongoose&apos;);mongoose.Promise = Promise;//连接数据库mongoose.connect(&apos;mongodb://localhost/blog&apos;);//定义schemavar UserSchema = new mongoose.Schema(&#123; name:String, age:Number&#125;);//定义Modelvar User = mongoose.model(&apos;User&apos;,UserSchema);var users = [];for(var i=0;i&lt;10;i++)&#123; users.push(&#123;name:&apos;zfpx&apos;+(i+1),age:i+1&#125;);&#125;/*User.create(users,function(err,docs)&#123; console.log(docs);&#125;);*//** * 分页查询 * pageNum 查询第几页 * pageSize 查询每页的条数 */var pageNum = 1;//查询第几页var pageSize = 10;//查询每页的条数// 跳过(忽略掉)前6条, 取3条User.find(&#123;&#125;) //当skip sort limit的时候并没有真正执行查询 // 当调用exec的时候才真正执行查询 .skip((pageNum-1)*pageSize)//跳过指定的条数 .limit(pageSize)//限定返回的条数 .sort(&#123;age:1&#125;)//排序，按哪个字段排序，正序1还是倒序-1 .exec(function(err,docs)&#123;//执行查询 console.log(err) console.log(docs);// 7 8 9 &#125;) 12345服务器的实例是谁？？？ 集合（默认时候模块名字就是集合名字） 文档 数据库：201613node db 查询有什么数据库，当还没有数据库是是test use 201613node 切换数据库 db.users.insert(&#123;id:1,name:&apos;zfpx&apos;&#125;) 集合中插入 db.users.find() 集合中查找 123&lt;%- include ../includes/header.html%&gt; //头 //中间变的内容&lt;%- include ../includes/footer.html%&gt; //尾 123问题整理：__v什么意思update第三参数 &#123;multy:true&#125;甚意思mongoose.Promise = Promise;什么作用 12345678ls List all the registries current Show current registry name use &lt;registry&gt; Change registry to registry add &lt;registry&gt; &lt;url&gt; [home] Add one custom registry del &lt;registry&gt; Delete one custom registry home &lt;registry&gt; [browser] Open the homepage of registry with optional browser test [registry] Show response time for specific or all registries help Print this help 12dest上传的文件路径 通用中间件，不通用的renderflash里的消息一旦取值就销毁，一闪而过 数据库操作12使用数据库，切换数据库use 11111 （11111代表数据库的名字） 123查看所有数据库show dbs备注: 我们刚创建的数据库person 如果不在列表内， 要显示它，我们需要向 person 数据库插入一些数据 db.person.insert(&#123;name:&quot;zhangSan&quot;,age:30&#125;) 12查看当前使用的数据库db 或者 db.getName() 12删除数据库db.dropDatabase() 集合操作12查看帮助db.user.help() 12查看数据库下的集合show collections 12创建集合show collections","tags":[]},{"title":"gulp","date":"2016-11-16T17:08:58.000Z","path":"2016/11/17/gulp/","text":"gulp12npm install //项目依赖和安装依赖都安装npm install production //只安装项目依赖 1npm install gulp gulp-less gulp-concat gulp-uglify gulp-rename gulp-clean-css gulp-minify-html gulp-inject gulp-babel gulp-plumber gulp-connect gulp-load-plugins --save-dev gulp使用方法 1.全局安装gulp 2.在当前目录下创建一个gulp的配置文件gulpfile.js里面可以定义gulp任务 3.在命令行中执行gulp 任务名（如：gulp js） 1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);// var less = require(&apos;gulp-less&apos;);// var concat = require(&apos;gulp-concat&apos;);// var uglify = require(&apos;gulp-uglify&apos;);// var rename = require(&apos;gulp-rename&apos;);var $ = require(&apos;./gulp-load-plugins&apos;)();//相当于引入所有的依赖//定义一个JS任务gulp.task(&apos;js&apos;,function()&#123; // &#123;filename:&apos;a.js&apos;,content:&apos;a内容&apos;&#125; // &#123;filename:&apos;b.js&apos;,content:&apos;b内容&apos;&#125; gulp.src(&apos;./app/js/*.js&apos;) //把多个文件合并成一个文件并指定合并后的文件名 .pipe($.concat(&apos;all.js&apos;)) //再向硬盘保存一次 .pipe(gulp.dest(&apos;./build/js&apos;)) //文件夹名 //再压缩 .pipe($.uglify()) //再重命名 .pipe($.rename(&apos;all.min.js&apos;)) // 最后再保存一次 // &#123;filename:&apos;all.js&apos;,content:&apos;ab内容&apos;&#125; .pipe(gulp.dest(&apos;./build/js&apos;));&#125;); 安装babel1npm install babel-cli -g 使用预设 npm install babel-preset-es2015npm install babel-preset-es2016npm install babel-preset-vuenpm install babel-preset-react1234&lt;!-- .babelrc 文件中 --&gt;&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; reduce item为每一项 curr初始值为第二个参数的值12345678910111213141516171819var attrs = [1,2,3];var r = attrs.reduce(function(curr,item)&#123; console.log(&apos;item&apos;+item); console.log(&apos;curr&apos;+curr); console.log(curr*2 + item) return curr*2 + item;&#125;,0)console.log(r);&lt;!-- 输出结果 --&gt;item1curr01item2curr14item3curr41111 gulp npm install gulp –save-dev 通过require可以把gulp模块引入当前项目并赋值给gulp变量 这样gulp这个变量里面就会拥有gulp的所有的方法了1var gulp = require(&apos;gulp&apos;); gulp.task(参数1，参数2):创建一个任务123456789var gulp = require(&apos;gulp&apos;);/** * gulp.task(参数1，参数2):创建一个任务 * 1参数 是任务的名称 * 2参数 是任务定义函数 */gulp.task(&apos;hello&apos;,function()&#123; console.log(&apos;hello&apos;);&#125;); gulp.src(‘./app/index.html’)src得到的是一个可读流,获取到想要处理的文件流12gulp.src([&apos;./build/css/all.min.css&apos;,&apos;./build/js/all.min.js&apos;]);//数组gulp.src(&apos;./app/index.html&apos;);//字符串 123456789101112/** * src得到的是一个可读流 * 可读流里放的就不是单纯字节内容了，而是一个一个的对象 * &#123; * filename:&apos;文件名&apos;, * content:&apos;文件内容&apos; * &#125; */ gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;)); &#125;); gulp.dest(‘./build/index.html’) 复制1234gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;));&#125;); gulp.js工作方式12345gulp的使用流程一般是1.首先通过`gulp.src()`方法获取到想要处理的文件流2.然后把文件流通过pipe方法导入到gulp的插件中3.最后把经过插件处理后(把less文件转为css文件)的流再通过pipe方法导入到`gulp.dest()`中4.`gulp.dest()`方法则把流中的内容写入到文件中 12345gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.less&apos;]) .pipe(less()) .pipe(gulp.dest(&apos;./build/index.css&apos;));&#125;); watch监听1234567891011gulp.task(&apos;watch&apos;,function()&#123; &lt;!-- //当参数1发生改变时，调用copy和log任务 --&gt; gulp.watch(&apos;./app/*.html&apos;,[&apos;copy&apos;,&apos;log&apos;]);&#125;);gulp.task(&apos;watch&apos;,function()&#123; &lt;!-- //当参数1发生改变时，事件类型 --&gt; gulp.watch(&apos;./app/*.html&apos;,function(event)&#123; &lt;!-- type类型 1.added 2.deleted 3.changed --&gt; console.log(event); &#125;)&#125;); 事件类型，1.added（这个没有效果） 2.deleted 3.changed123&lt;!-- 修改文件内容 --&gt;&#123; type: &apos;changed&apos;, path: &apos;E:\\\\node课件\\\\2017.2.22\\\\app\\\\base.html&apos; &#125; 123&lt;!-- 删除文件 --&gt;&#123; type: &apos;deleted&apos;, path: &apos;E:\\\\node课件\\\\2017.2.22\\\\app\\\\44444.html&apos; &#125; api完成代码123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);/** * 1参数 是任务的名称 * 2参数 是任务定义函数 */gulp.task(&apos;hello&apos;,function()&#123; console.log(&apos;hello&apos;);&#125;);/** * src得到的是一个可读流 * 可读流里放的就不是单纯字节内容了，而是一个一个的对象 * &#123; * filename:&apos;文件名&apos;, * content:&apos;文件内容&apos; * &#125; */gulp.task(&apos;copy&apos;,function()&#123; gulp.src([&apos;./app/index.html&apos;]) .pipe(gulp.dest(&apos;./build/index.html&apos;));&#125;);gulp.task(&apos;log&apos;,function()&#123; console.log(&apos;log&apos;);&#125;)// type added deleted changed/*gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/*.html&apos;,[&apos;copy&apos;,&apos;log&apos;]); &#125;);*/gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/*.html&apos;,function(event)&#123; console.log(event); &#125;)&#125;); gulp插件：gulp提供了很多借口，但是本身并不能做太多的事情，其他实用的功能都是依靠插件来进行扩展的gulp-less插件可以把less文件编译成css .pipe(less()),里面没有参数 npm install gulp-less –save-dev1234567891011&lt;!-- css --&gt;var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;./app/less/*.less&apos;)//*******less .pipe(less()) .pipe(gulp.dest(&apos;./build/css&apos;));//*******css&#125;);gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/less/*.less&apos;,[&apos;css&apos;])&#125;) gulp-concat把几个文件合并到一块 npm install gulp-concat –save-dev123var concat = require(&apos;gulp-concat&apos;);//把多个文件合并成一个文件并指定合并后的文件名.pipe($.concat(&apos;all.js&apos;)) gulp-uglify对js文件进行压缩,此插件不能压缩es6，需要编译成es5在压缩 npm install gulp-uglify –save-dev12var uglify = require(&apos;gulp-uglify&apos;);.pipe($.uglify()) gulp-clean-css对css文件进行压缩 npm install gulp-clean-css –save-dev12var cleanCss = require(&apos;gulp-clean-css&apos;);.pipe($.cleanCss()) gulp-minify-html 对html文件进行压缩 npm install gulp-minify-html –save-dev12var minifyHtml = require(&apos;gulp-minify-html&apos;);.pipe($.minifyHtml()) gulp-rename在把处理好的文件存放的指定位置之前，我们可以先重命名一下它 npm install gulp-rename –save-dev1234var rename = require(&apos;gulp-rename&apos;);//再重命名为&apos;all.min.js&apos;&lt;!-- 可以为字符串 --&gt;.pipe($.rename(&apos;all.min.js&apos;)) 123456&lt;!-- 可以为函数 --&gt;.pipe($.rename(function(file)&#123; console.log(file) &lt;!-- &#123; dirname: &apos;.&apos;, basename: &apos;all&apos;, extname: &apos;.css&apos; &#125; --&gt; file.basename += &apos;.min&apos;;****** &#125;)) gulp-connect 有时候我们需要把文件放到本地服务器上去预览，他可以帮我们创建一个本地的服务器去运行我们的项目 npm install gulp-connect –save-dev12345678gulp.task(&apos;serve&apos;,function()&#123; //启动HTTP服务 $.connect.server(&#123; port:8080,//端口号 root:&apos;./build&apos;,//服务器的根目录 livereload:true//服务启动自动刷新 &#125;);&#125;); gulp-load-plugins自动加载所有的插件 npm install gulp-load-plugins –save-dev123var $ = require(&apos;gulp-load-plugins&apos;)();//再重命名为&apos;all.min.js&apos;.pipe($.rename(&apos;all.min.js&apos;)) gulp-babel:可以使用此插件吧es6的代码编译成es5代码 npm install gulp-babel –save1234567var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;js&apos;,function()&#123; gulp.src(&apos;./app/js/es6.js&apos;) .pipe($.babel(&#123;presets:[&quot;es2015&quot;]&#125;)) .pipe(gulp.dest(&apos;./build/js&apos;))&#125;); gulp-inject 动态自动插入生成后的js和css文件到html npm install gulp-inject –save-dev12345678910111213var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;html&apos;,function()&#123; //要插入的目标文件流 var target = gulp.src(&apos;./app/index.html&apos;); //将要被插入的资源 var source = gulp.src([&apos;build/css/all.min.css&apos;,&apos;build/js/all.min.js&apos;]); target //ignorePath:&apos;build&apos;:忽略build路径 //addRootSlash:false:是否添加跟斜线（/） .pipe($.inject(source,&#123;ignorePath:&apos;build&apos;,addRootSlash:false&#125;)) .pipe(gulp.dest(&apos;./build&apos;))&#125;); gulp-load-plugins实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- gulp-load-plugins实现原理 --&gt;/** * 1. 读取package.json文件的devDependencies配置项 * 2. 寻找gulp-开头的那些属性。 * 3. 加载这些模块，并把返回值挂到$的属性上(属性名就是模块名去掉gulp-,后面变成驼峰命名法) *//** * 1. 读取package.json文件的devDependencies配置项 * 2. 寻找gulp-开头的那些属性。 * 3. 加载这些模块，并把返回值挂到$的属性上(属性名就是模块名去掉gulp-,后面变成驼峰命名法) */function load() &#123; var $=&#123;&#125;; var package = require(&apos;./package.json&apos;); var dev = package.devDependencies; /*for(var key in dev)&#123; if(/^gulp-/.test(key))&#123; $[toKey(key)] = require(key); &#125; &#125;*/ Object.keys(dev).forEach(function(key)&#123; if(/^gulp-/.test(key))&#123; $[toKey(key)] = require(key); &#125; &#125;); console.log(Object.keys(dev)); &lt;!-- Object.keys(dev)是把dev对象的属性名转换为数组 [ &apos;gulp&apos;, &apos;gulp-babel&apos;, &apos;gulp-clean-css&apos;, &apos;gulp-concat&apos;, &apos;gulp-connect&apos;, &apos;gulp-inject&apos;, &apos;gulp-less&apos;, &apos;gulp-load-plugins&apos;, &apos;gulp-minify-html&apos;, &apos;gulp-plumber&apos;, &apos;gulp-rename&apos;, &apos;gulp-uglify&apos; ] --&gt; return $&#125;function toKey(key) &#123; return key.slice(5).replace(/-(\\w)/g, function () &#123; return arguments[1].toUpperCase(); &#125;)&#125;module.exports = load; Object.keys(dev)是把dev对象的属性名转换为数组123456789101112[ &apos;gulp&apos;, &apos;gulp-babel&apos;, &apos;gulp-clean-css&apos;, &apos;gulp-concat&apos;, &apos;gulp-connect&apos;, &apos;gulp-inject&apos;, &apos;gulp-less&apos;, &apos;gulp-load-plugins&apos;, &apos;gulp-minify-html&apos;, &apos;gulp-plumber&apos;, &apos;gulp-rename&apos;, &apos;gulp-uglify&apos; ] js1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);// var less = require(&apos;gulp-less&apos;);// var concat = require(&apos;gulp-concat&apos;);// var uglify = require(&apos;gulp-uglify&apos;);// var rename = require(&apos;gulp-rename&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();//定义一个JS任务gulp.task(&apos;js&apos;,function()&#123; // &#123;filename:&apos;a.js&apos;,content:&apos;a内容&apos;&#125; // &#123;filename:&apos;b.js&apos;,content:&apos;b内容&apos;&#125; gulp.src(&apos;./app/js/*.js&apos;) //把多个文件合并成一个文件并指定合并后的文件名 .pipe($.concat(&apos;all.js&apos;)) //再向硬盘保存一次 .pipe(gulp.dest(&apos;./build/js&apos;)) //再压缩 .pipe($.uglify()) //再重命名 .pipe($.rename(&apos;all.min.js&apos;)) // 最后再保存一次 // &#123;filename:&apos;all.js&apos;,content:&apos;ab内容&apos;&#125; .pipe(gulp.dest(&apos;./build/js&apos;));&#125;); css123456789101112131415161718192021222324var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();/** * 1. 把less编译成css * 2. 把多个CSS文件合并成同一个 * 3. 先保存一次压缩前的合并文件 * 4. 进行压缩 * 5. 对压缩后的文件进行重命名 * 6. 再保存一次 **/gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;./app/less/*.less&apos;) .pipe($.less()) .pipe($.concat(&apos;all.css&apos;)) .pipe(gulp.dest(&apos;./build/css&apos;)) .pipe($.cleanCss()) // all.css all.min.css .pipe($.rename(function(file)&#123; console.log(file) &lt;!-- &#123; dirname: &apos;.&apos;, basename: &apos;all&apos;, extname: &apos;.css&apos; &#125; --&gt; file.basename += &apos;.min&apos;;****** &#125;)) .pipe(gulp.dest(&apos;./build/css&apos;))&#125;); html1234567891011121314var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();/** * 1. 获取app下面的所有的html * 2. 对html文件进行压缩 * 3. 保存压缩后HTML文件 * * 只能匹配任意字符，但不能路径分隔符 * ** 可以匹配任意字符，包括路径分隔符 **/gulp.task(&apos;html&apos;,function()&#123; gulp.src(&apos;./app/**/*.html&apos;) .pipe($.minifyHtml()) .pipe(gulp.dest(&apos;./build&apos;));&#125;); server 实现自动刷新1234567891011121314151617181920212223var gulp = require(&apos;gulp&apos;);var $ = require(&apos;gulp-load-plugins&apos;)();gulp.task(&apos;html&apos;,function()&#123; gulp.src(&apos;./app/index.html&apos;).pipe(gulp.dest(&apos;./build&apos;)) //拷贝完成后通知浏览器自动刷新一下 .pipe($.connect.reload())&#125;);gulp.task(&apos;watch&apos;,function()&#123; gulp.watch(&apos;./app/index.html&apos;,[&apos;html&apos;]);&#125;);// /index.htmlgulp.task(&apos;serve&apos;,function()&#123; //启动HTTP服务 $.connect.server(&#123; port:8080, root:&apos;./build&apos;, //启动自动刷新 livereload:true &#125;);&#125;);//此任务依赖的其它任务 组合任务gulp.task(&apos;default&apos;,[&apos;serve&apos;,&apos;watch&apos;]);","tags":[]},{"title":"jQuery","date":"2016-04-16T17:08:58.000Z","path":"2016/04/17/jQuery/","text":"核心 找到所有p元素，并且这些元素都为div元素的子元素1$(&quot;div&gt;p&quot;) 设置页面背景 1$(document.body).css(&quot;background&quot;:&quot;red&quot;) 隐藏一个表单中所有元素 1$(myForm.elements).hide() 在文档的第一个表单中，查找所有单选按钮(即：type值为radio的input元素) 1$(&quot;input:radio&quot;,document.forms[0]) 在一个ajax返回的xml文档中，查找所有div元素 1$(&quot;div&quot;,xml.responseXML) 动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。 选择器 #id id选择器 12345678查找 ID 为&quot;myDiv&quot;的元素:$(&quot;#myDiv&quot;);得到的结果:[ &lt;div id=&quot;myDiv&quot;&gt;id=&quot;myDiv&quot;&lt;/div&gt; ]查找含有特殊字符的元素:$(&quot;#foo\\\\[bar\\\\]&quot;)得到的结果:[ &lt;span id=&quot;foo[bar]&quot;&gt;&lt;/span&gt;]$(&quot;#foo\\\\.bar&quot;)得到的结果:[ &lt;span id=&quot;foo.bar&quot;&gt;&lt;/span&gt;] element 元素选择器 12$(&quot;div&quot;);得到的结果:[ &lt;div&gt;DIV1&lt;/div&gt;, &lt;div&gt;DIV2&lt;/div&gt; ] .class 类选择器 12$(&quot;.myClass&quot;);得到的结果:[ &lt;div class=&quot;myClass&quot;&gt;div class=&quot;myClass&quot;&lt;/div&gt;, &lt;span class=&quot;myClass&quot;&gt;span class=&quot;myClass&quot;&lt;/span&gt; ] *通配符选择器 得到所有的标签元素 12$(&quot;*&quot;);得到的结果:[ &lt;div&gt;DIV&lt;/div&gt;, &lt;span&gt;SPAN&lt;/span&gt;, &lt;p&gt;P&lt;/p&gt; ] parent &gt; child,在给定的父元素下匹配所有的子元素; 123parent可以为任何有效选择器，child用以匹配元素的选择器，并且它是第一个选择器的子元素得到的结果只能是form选择器的子元素，同一级的元素和孙子级的都得不到[ &lt;input name=&quot;name&quot; /&gt; ] 1$(&quot;form &gt; input&quot;); prev + next,匹配所有紧接在 prev 元素后的 next 元素;12345678910111213prev任何有效选择器，next匹配一个选择器，并且紧接着第一个选择器&lt;!--&lt;form&gt; &lt;label&gt;Name:&lt;/label&gt; &lt;input name=&quot;name&quot; /&gt; &lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name=&quot;newsletter&quot; /&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;input name=&quot;none&quot; /&gt;--&gt;得到的结果：[ &lt;input name=&quot;name&quot; /&gt;, &lt;input name=&quot;newsletter&quot; /&gt; ] 1$(&quot;label+input&quot;) prev ~ siblings,匹配 prev 元素之后的所有 siblings 元素;123prev为任何有效元素，siblings为一个选择器，并且是第一个选择器的同辈得到的结果：[ &lt;input name=&quot;none&quot; /&gt; ] 1$(&quot;form~input&quot;); :first获取匹配的第一个元素 12$(&quot;li:first&quot;);得到的结果：[ &lt;li&gt;list item 1&lt;/li&gt; ] :not(selector)去除所有与给定选择器匹配的元素 123456&lt;!-- &lt;input name=&quot;apple&quot; /&gt; &lt;input name=&quot;flower&quot; checked=&quot;checked&quot; /&gt;--&gt;$(&quot;input:not(:checked)&quot;)查找所有未选中的 input 元素得到的结果：[ &lt;input name=&quot;apple&quot; /&gt; ] :even匹配所有索引值为偶数的元素，从0开始计数 12$(&quot;tr:even&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ] :odd匹配所有索引值为奇数的元素，从0开始计数 12$(&quot;tr:odd&quot;);得到的结果:[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :eq(index)匹配一个给定索引值的元素，index从0开始计数 12$(&quot;tr:eq(1)&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :gt(index)匹配所有大于给定索引值的元素，index从0开始计数 12$(&quot;tr:gt(0)&quot;)得到的结果：[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ] :last获取匹配的最后一个元素 12$(&quot;tr:last&quot;)得到的结果：[ &lt;li&gt;list item 5&lt;/li&gt; ] :lt(index)获取所有小于给定索引值的元素 12$(&quot;tr:lt(2)&quot;)获取到的结果：[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ] :header 匹配如：h1,h2,h3之类的标题元素 12$(&quot;:header&quot;).css(&quot;background&quot;,&quot;#EEE&quot;)得到的结果：[ &lt;h1 style=&quot;background:#EEE;&quot;&gt;Header 1&lt;/h1&gt;, &lt;h2 style=&quot;background:#EEE;&quot;&gt;Header 2&lt;/h2&gt; ] :animated匹配所有正在执行动画效果的元素 123$(&quot;#run&quot;).click(function()&#123; $(&quot;div:not(:animated)&quot;).animate(&#123;left:&quot;+=20&quot;&#125;,1000);&#125;) 如果不确定返回的数据是jq对象还是js元素，可以alert一下，看返回的是object还是element，如果是object为jq元素，如果为element为js元素","tags":[]},{"title":"上传博客","date":"2016-02-16T17:08:58.000Z","path":"2016/02/17/post/","text":"npm node package mana 安装完node后自带送一个npm 安装前端包 bower 安装后台包 npm 切换源（nrm切换工具） 将下载的网址切换到珠峰(把外网切换为珠峰内网) 1npm config set registry &quot;http://172.18.0.199&quot; 全局安装本地安装 起到切换源的作用1npm install nrm -g 只在命令行下使用才加-g属性 显示所有源1nrm ls 使用源1nrm use taobao 添加珠峰源1nrm add zhufeng http://172.18.0.199 删除存在的源1nrm del zhufeng 测试网速1nrm test 搭建博客（自动生成 hexo） 唯一性 一个github账号只能有一个1npm install hexo-cli -g 生成博客12mkdir jwTest &amp;&amp;cd jwTesthexo init 启动服务1hexo server -p 5000 发布github(安装插件)12npm install hexo-deployer-git --save发布的时候不用输入账号密码 重新生成1hexo g 发布12hexo deploy第一次发布会生成.deploy_git文件 一些常用的命令1234567hexo new &quot;postName&quot; #新建文章 ..\\_posts\\222.mdhexo new page &quot;pageName&quot; #新建页面(文件夹) ..\\source\\1111\\index.mdhexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 静态页 gh-pagesgh-pages分支的名字，提供静态页的展示 初始化仓库git init 建立联系git remote add origin 创建并切换分支git checkout -b gh-pagh推送","tags":[]}]